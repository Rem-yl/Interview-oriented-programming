# 待办事项管理系统 - 架构演进学习项目

## 项目简介

这是一个通过产品迭代来学习不同软件架构设计的实战项目。我们将从最简单的单体架构开始，逐步演进到微服务、事件驱动等复杂架构，在迭代过程中理解每种架构的设计理念、优缺点和适用场景。

## 核心需求

**待办事项管理系统 (Todo Management System)**

### 基础功能（V1）
- 创建待办事项
- 查看待办事项列表
- 更新待办事项状态（完成/未完成）
- 删除待办事项

### 后续迭代功能
- V2: 添加用户系统（多用户）
- V3: 添加分类和标签
- V4: 添加搜索和筛选功能
- V5: 添加提醒通知功能
- V6: 添加统计分析功能

## 架构演进路线图

```
V1: 单体架构 (Monolithic)
    ↓ 问题：代码混乱，难以测试

V2: 分层架构 (Layered Architecture)
    ↓ 问题：业务逻辑与技术细节耦合

V3: 六边形架构 (Hexagonal Architecture)
    ↓ 问题：读写操作性能需求不同

V4: CQRS架构 (Command Query Responsibility Segregation)
    ↓ 问题：单体应用扩展性限制

V5: 微服务架构 (Microservices)
    ↓ 问题：服务间强耦合

V6: 事件驱动架构 (Event-Driven Architecture)
```

## 学习目标

1. **理解架构演进的必要性** - 随业务复杂度选择合适架构
2. **掌握分层思想** - 关注点分离、依赖管理
3. **学习领域驱动设计** - 以业务为核心的建模
4. **实践CQRS模式** - 读写分离优化
5. **体验微服务拆分** - 服务边界划分
6. **理解事件驱动** - 异步解耦、最终一致性

## 技术栈

- **语言**: Go 1.23.0
- **存储**: 从内存 → SQLite → PostgreSQL
- **框架**: Gin/Echo (HTTP), gorm (ORM)
- **消息队列**: 内存队列 → Redis → Kafka（后期）
- **序列化**: JSON
- **测试**: Go testing + testify

## 项目结构

```
system-arch/
├── README.md                 # 本文档
├── docs/                     # 架构设计文档
│   ├── v1-monolithic.md
│   ├── v2-layered.md
│   ├── v3-hexagonal.md
│   ├── v4-cqrs.md
│   ├── v5-microservices.md
│   └── v6-event-driven.md
├── v1-monolithic/           # V1: 单体架构
├── v2-layered/              # V2: 分层架构
├── v3-hexagonal/            # V3: 六边形架构
├── v4-cqrs/                 # V4: CQRS架构
├── v5-microservices/        # V5: 微服务架构
└── v6-event-driven/         # V6: 事件驱动架构
```

## 如何学习

### 学习流程

1. **阅读架构文档** - 理解架构设计理念
2. **查看目录结构** - 理解模块划分
3. **实现代码** - 按照文档要求编写
4. **运行测试** - 验证实现正确性
5. **对比分析** - 与上一版本对比，理解改进点
6. **思考总结** - 记录心得和疑问

### 建议步骤

```bash
# 1. 进入对应版本目录
cd v1-monolithic

# 2. 阅读该版本的架构文档
cat ../docs/v1-monolithic.md

# 3. 根据文档创建文件和实现代码
# 4. 初始化 Go 模块
go mod init github.com/yourusername/todo-v1

# 5. 运行程序
go run main.go

# 6. 运行测试
go test ./...

# 7. 完成后，进入下一个版本
cd ../v2-layered
```

## 评估标准

每个版本实现后，从以下维度评估：

| 维度 | 说明 |
|------|------|
| **可读性** | 代码是否清晰易懂 |
| **可测试性** | 是否容易编写单元测试 |
| **可维护性** | 修改功能是否容易 |
| **可扩展性** | 添加新功能是否方便 |
| **性能** | 响应速度、资源占用 |
| **复杂度** | 理解和实现的难度 |

## 架构对比总结

| 架构 | 复杂度 | 适用场景 | 主要优点 | 主要缺点 |
|------|--------|----------|----------|----------|
| 单体架构 | ⭐ | 原型、小型应用 | 简单快速 | 难以维护 |
| 分层架构 | ⭐⭐ | 中小型应用 | 结构清晰 | 层间耦合 |
| 六边形架构 | ⭐⭐⭐ | 复杂业务逻辑 | 业务独立 | 理解成本高 |
| CQRS | ⭐⭐⭐⭐ | 读写分离场景 | 性能优化 | 一致性复杂 |
| 微服务 | ⭐⭐⭐⭐⭐ | 大型分布式系统 | 独立扩展 | 运维复杂 |
| 事件驱动 | ⭐⭐⭐⭐ | 异步、解耦场景 | 高扩展性 | 调试困难 |

## 开始学习

现在，请从 [V1: 单体架构](./docs/v1-monolithic.md) 开始你的学习之旅！

## 学习资源

- **领域驱动设计**: 《实现领域驱动设计》
- **架构模式**: 《软件架构模式》
- **Go最佳实践**: https://github.com/golang-standards/project-layout
- **Clean Architecture**: Robert C. Martin

---

**祝你学习愉快！有问题随时讨论。**
