# 负载均衡器测试指南

## 目录结构

```
load-balancer/
├── cmd/
│   ├── lb/           # 负载均衡器主程序
│   └── server/       # 后端服务器程序
├── start_server.sh   # 启动多个服务器的脚本
├── stop_server.sh    # 停止所有服务器的脚本
├── status_server.sh  # 查看服务器状态的脚本
├── bin/              # 编译输出目录（自动创建）
├── logs/             # 服务器日志目录（自动创建）
└── pids/             # 进程 PID 文件目录（自动创建）
```

## 快速开始

### 1. 启动多个后端服务器

```bash
./start_server.sh
```

**这个脚本会做什么**：
- 编译 `cmd/server/main.go` 到 `bin/server`
- 启动 5 个后端服务器实例（端口：8081-8085）
- 每个服务器在后台运行，日志输出到 `logs/server-<端口>.log`
- 保存每个服务器的 PID 到 `pids/server-<端口>.pid`
- 自动进行健康检查验证

**预期输出**：
```
========================================
  负载均衡器测试环境启动脚本
========================================

[1/3] 编译服务器程序...
✓ 编译成功

[2/3] 启动服务器实例...
✓ 服务器已启动: 端口 8081 (PID: 12345)
✓ 服务器已启动: 端口 8082 (PID: 12346)
✓ 服务器已启动: 端口 8083 (PID: 12347)
✓ 服务器已启动: 端口 8084 (PID: 12348)
✓ 服务器已启动: 端口 8085 (PID: 12349)

[3/3] 验证服务器状态...
✓ 端口 8081: 运行中 (PID: 12345) - 健康检查通过
✓ 端口 8082: 运行中 (PID: 12346) - 健康检查通过
...

========================================
启动完成！运行中的服务器: 5/5
========================================
```

### 2. 查看服务器状态

```bash
./status_server.sh
```

**输出示例**：
```
========================================
  后端服务器状态
========================================

端口     PID        状态         健康检查
----     ----       ----         ----------
8081     12345      运行中       ✓ 正常
8082     12346      运行中       ✓ 正常
8083     12347      运行中       ✓ 正常
8084     12348      运行中       ✓ 正常
8085     12349      运行中       ✓ 正常

========================================
总计: 5/5 运行中
========================================
```

### 3. 测试服务器

```bash
# 健康检查端点
curl http://localhost:8081/health
# 返回: {"data":"healthy"}

# 普通请求
curl http://localhost:8081/
# 返回: {"data":"Hello, you are run on port: 8081"}
```

### 4. 停止所有服务器

```bash
./stop_server.sh
```

**这个脚本会做什么**：
- 读取所有 PID 文件
- 优雅关闭每个服务器进程（SIGTERM）
- 如果优雅关闭失败，强制关闭（SIGKILL）
- 清理所有 PID 文件

## 设计思路

### 为什么需要这些脚本？

在测试负载均衡器时，我们需要：
1. **多个后端服务器**：验证负载分配是否均匀
2. **独立的进程**：模拟真实的分布式环境
3. **健康检查端点**：测试负载均衡器的健康检查机制
4. **便捷的管理**：快速启动/停止所有服务器

### 关键设计点

#### 1. **进程管理**（`start_server.sh`）

```bash
# 后台启动并重定向输出
nohup "$BUILD_DIR/server" -port "$port" > "$LOG_DIR/server-$port.log" 2>&1 &

# 保存 PID 用于后续管理
echo $! > "$PID_DIR/server-$port.pid"
```

**设计权衡**：
- ✅ **使用 nohup**：进程不会因为终端关闭而结束
- ✅ **输出重定向**：每个服务器的日志独立存储，便于调试
- ✅ **保存 PID**：可以精确控制每个进程的生命周期

#### 2. **端口冲突检测**

```bash
if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1 ; then
    echo "警告: 端口 $port 已被占用，跳过"
    continue
fi
```

**设计权衡**：
- ✅ **主动检测**：避免启动失败
- ✅ **跳过而非失败**：允许部分服务器运行
- ⚠️ **性能开销**：每次启动都要检测

#### 3. **健康检查验证**（`start_server.sh`）

```bash
if curl -s "http://localhost:$port/health" > /dev/null 2>&1; then
    echo "✓ 端口 $port: 运行中 - 健康检查通过"
else
    echo "⚠ 端口 $port: 运行中 - 健康检查失败"
fi
```

**设计权衡**：
- ✅ **立即验证**：确保服务器真正可用
- ✅ **区分启动与可用**：进程运行 ≠ 服务可用
- ⚠️ **时间开销**：增加启动时间

#### 4. **优雅关闭**（`stop_server.sh`）

```bash
# 先发送 SIGTERM（优雅关闭）
kill $PID

# 等待最多 5 秒
for i in {1..10}; do
    if ! ps -p $PID > /dev/null 2>&1; then
        break
    fi
    sleep 0.5
done

# 如果还在运行，强制关闭 SIGKILL
if ps -p $PID > /dev/null 2>&1; then
    kill -9 $PID
fi
```

**设计权衡**：
- ✅ **两阶段关闭**：优先优雅，兜底强制
- ✅ **超时机制**：避免无限等待
- ⚠️ **复杂度**：需要额外的等待和检查逻辑

## 高级用法

### 自定义端口列表

编辑 `start_server.sh` 的配置区：

```bash
# 修改这行来添加/删除服务器端口
PORTS=(8081 8082 8083 8084 8085 8086 8087)
```

### 查看特定服务器日志

```bash
# 实时查看端口 8081 的日志
tail -f logs/server-8081.log

# 查看所有服务器日志
tail -f logs/server-*.log
```

### 手动启动单个服务器

```bash
# 编译服务器程序（如果还没编译）
go build -o bin/server ./cmd/server/main.go

# 启动单个服务器
./bin/server -port 8090
```

### 集成到负载均衡器测试

```bash
# 1. 启动后端服务器
./start_server.sh

# 2. 启动负载均衡器（需要你实现）
go run cmd/lb/main.go

# 3. 测试负载均衡
for i in {1..10}; do
    curl http://localhost:8080/  # 假设负载均衡器在 8080
done

# 4. 查看请求分布（查看各服务器日志）
./status_server.sh

# 5. 停止所有服务
./stop_server.sh
```

## 测试场景

### 场景 1：验证轮询算法

```bash
# 启动 3 个服务器
# 修改 PORTS=(8081 8082 8083)

# 发送 9 个请求，预期每个服务器收到 3 个请求
for i in {1..9}; do
    curl http://localhost:<负载均衡器端口>/
done

# 检查日志验证分布
grep "GET /" logs/server-*.log | wc -l  # 应该显示 9
```

### 场景 2：模拟服务器故障

```bash
# 启动所有服务器
./start_server.sh

# 手动停止一个服务器
kill $(cat pids/server-8083.pid)

# 测试负载均衡器是否能检测到故障并排除该节点
curl http://localhost:<负载均衡器端口>/

# 重启故障服务器
./bin/server -port 8083 &
```

### 场景 3：压力测试

```bash
# 使用 ab（Apache Bench）进行压力测试
ab -n 10000 -c 100 http://localhost:<负载均衡器端口>/

# 查看各服务器的负载分布
./status_server.sh
```

## 常见问题

### Q1: 启动时提示 "端口已被占用"

**解决方案**：
```bash
# 查找占用端口的进程
lsof -i :8081

# 停止占用端口的进程
kill -9 <PID>

# 或者修改 PORTS 配置使用其他端口
```

### Q2: 健康检查失败

**可能原因**：
1. 服务器启动较慢（Gin 初始化需要时间）
2. 端口被防火墙阻止
3. curl 命令不可用

**解决方案**：
```bash
# 增加等待时间（修改 start_server.sh）
sleep 2  # 原本是 sleep 1

# 手动检查
curl http://localhost:8081/health
```

### Q3: 停止脚本无法关闭进程

**解决方案**：
```bash
# 强制杀死所有服务器进程
pkill -f "bin/server"

# 清理 PID 文件
rm -rf pids/
```

## 扩展性建议

### 1. 添加配置文件支持

创建 `servers.conf`：
```bash
# servers.conf
8081
8082
8083
8084
8085
```

修改脚本读取配置：
```bash
PORTS=($(cat servers.conf))
```

### 2. 支持不同的服务器类型

```bash
# 启动参数支持服务器配置
./bin/server -port 8081 -delay 100ms  # 模拟慢服务器
./bin/server -port 8082 -error-rate 0.1  # 模拟不稳定服务器
```

### 3. 集成到 Docker

创建 `docker-compose.yml` 来管理多个服务器容器。

### 4. 添加监控

```bash
# 在 status_server.sh 中添加 CPU、内存监控
ps -p $PID -o %cpu,%mem,vsz,rss
```

## 下一步

使用这些脚本后，你可以开始：

1. **实现负载均衡器的核心功能**
   - 参考 `DEVELOPMENT_GUIDE.md` 的迭代步骤
   - 从简单的轮询算法开始

2. **集成健康检查**
   - 定期调用 `/health` 端点
   - 根据响应标记节点状态

3. **添加故障转移**
   - 检测不健康的节点
   - 自动从池中移除

4. **性能测试**
   - 使用 `ab` 或 `wrk` 进行压测
   - 分析负载分布是否均匀

祝你测试顺利！
