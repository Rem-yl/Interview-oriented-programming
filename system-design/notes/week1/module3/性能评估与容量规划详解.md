# Week 1 - 模块 3: 性能评估与容量规划详解

> **学习目标**: 掌握系统性能指标的计算方法和容量规划的实践技能

---

## 第一部分: QPS vs TPS - 吞吐量指标

### 1.1 核心概念

#### QPS (Queries Per Second)
- **定义**: 每秒查询数，服务器每秒能够处理的查询请求数量
- **适用场景**: 读密集型服务（搜索引擎、API Gateway）
- **计算公式**: `QPS = 总请求数 / 总时间(秒)`

#### TPS (Transactions Per Second)
- **定义**: 每秒事务数，服务器每秒能够处理的事务数量
- **适用场景**: 写密集型服务（支付系统、订单系统）
- **计算公式**: `TPS = 总事务数 / 总时间(秒)`

#### 区别与联系

| 维度 | QPS | TPS |
|------|-----|-----|
| 粒度 | 单个请求 | 一组原子操作 |
| 典型场景 | GET /api/users | 转账操作(查余额+扣款+加款+记日志) |
| 关系 | 1个事务可能包含多个查询 | 1 TPS 可能对应 3-5 QPS |
| 数据库操作 | SELECT查询 | BEGIN; UPDATE; INSERT; COMMIT; |

### 1.2 实际计算示例

#### 案例 1: 电商系统 QPS 估算

**需求分析**:
- DAU (日活用户): 100 万
- 每个用户平均每天发起请求: 20 次
- 流量分布: 集中在 10:00-22:00 (12小时)
- 峰值因子: 3倍（某些时段流量是平均值的3倍）

**计算步骤**:

```
1. 总请求数/天 = 1,000,000 × 20 = 20,000,000 次

2. 平均 QPS = 20,000,000 / 86,400秒 ≈ 231.5 QPS

3. 活跃时段平均 QPS (12小时)
   = 20,000,000 / (12 × 3600)
   = 20,000,000 / 43,200
   ≈ 463 QPS

4. 峰值 QPS = 463 × 3 ≈ 1,389 QPS

5. 系统设计目标 QPS (留20%冗余)
   = 1,389 × 1.2 ≈ 1,667 QPS
```

**架构决策**:
- 单机 Nginx: 可处理 5,000+ QPS → **够用**
- 但需考虑后端服务能力（Go/Python应用通常 500-2000 QPS）
- 建议配置 2-3 台应用服务器做负载均衡

#### 案例 2: 支付系统 TPS 估算

**需求分析**:
- 日订单量: 50 万笔
- 峰值时段: 晚上 8-10 点（2小时占全天 30%）
- 峰值因子: 5倍

**计算步骤**:

```
1. 平均 TPS = 500,000 / 86,400 ≈ 5.8 TPS

2. 峰值时段订单量 = 500,000 × 30% = 150,000 笔

3. 峰值时段平均 TPS = 150,000 / (2 × 3600)
   = 150,000 / 7,200
   ≈ 20.8 TPS

4. 瞬时峰值 TPS = 20.8 × 5 ≈ 104 TPS

5. 系统设计目标 TPS (2倍冗余)
   = 104 × 2 ≈ 208 TPS
```

**架构决策**:
- MySQL 主库写能力: 单机约 1,000-3,000 TPS → **够用**
- 但需考虑事务复杂度（多表写入会降低 TPS）
- 建议增加缓存层减少 DB 压力

---

## 第二部分: Latency 分析 - 延迟指标

### 2.1 为什么平均值不够？

**场景**: Web API 响应时间统计

| 请求序号 | 响应时间 |
|----------|----------|
| 1-90     | 10ms     |
| 91-95    | 50ms     |
| 96-98    | 200ms    |
| 99       | 500ms    |
| 100      | 5000ms (超时) |

**计算结果**:
- **平均值**: (10×90 + 50×5 + 200×3 + 500 + 5000) / 100 = **105.5ms**
- **用户感知**: 10% 用户体验到 >50ms 延迟，1% 用户等待 5 秒！

**问题**: 平均值掩盖了长尾延迟，无法反映真实用户体验。

### 2.2 百分位数 (Percentile)

#### 定义
- **P50 (中位数)**: 50% 的请求延迟小于此值
- **P95**: 95% 的请求延迟小于此值
- **P99**: 99% 的请求延迟小于此值
- **P99.9**: 99.9% 的请求延迟小于此值

#### 手工计算示例

**数据集**: [1, 2, 3, 4, 5, 10, 15, 20, 50, 100] ms (共10个样本，已排序)

```
P50 = 第 10×50% = 第5个和第6个的平均值
    = (5 + 10) / 2 = 7.5ms

P95 = 第 10×95% = 第9.5个 ≈ 第10个值
    = 100ms (或用插值法)

P99 = 第 10×99% = 第9.9个 ≈ 第10个值
    = 100ms
```

**更大数据集**: [1ms, 2ms, ..., 100ms] (100个样本)

```
排序后:
P50 = 第 50个值 = 50ms
P95 = 第 95个值 = 95ms
P99 = 第 99个值 = 99ms
```

### 2.3 为什么 P99 比平均值重要？

#### SLA (Service Level Agreement) 制定

```
Twitter API SLA 示例:
✓ P50 < 20ms   (普通用户体验)
✓ P95 < 100ms  (大部分用户可接受)
✓ P99 < 500ms  (避免极端差体验)
✓ P99.9 < 2s   (容忍极少数超时)
```

#### 业务影响

**案例**: 电商首页加载
- 如果 P99 = 3s，意味着每 100 个用户中有 1 个等待超过 3 秒
- 日 UV 1000 万 → **每天 10 万用户体验差** → 流失风险

#### 尾延迟放大效应

**微服务场景**: 用户请求需调用 10 个下游服务

```
假设每个服务 P99 = 100ms (即 1% 概率超时)

至少有1个服务超时的概率 = 1 - (1 - 0.01)^10
                        = 1 - 0.99^10
                        ≈ 9.6%

即用户请求的整体 P90 延迟 = 单个服务的 P99 延迟！
```

**启示**: 微服务越多，尾延迟影响越大，必须严格控制 P99。

### 2.4 实战: 如何测量和优化延迟

#### 工具推荐

**Go 项目**:
```go
import "github.com/prometheus/client_golang/prometheus"

// 定义 Histogram 指标
var requestDuration = prometheus.NewHistogram(
    prometheus.HistogramOpts{
        Name:    "http_request_duration_seconds",
        Buckets: []float64{0.01, 0.05, 0.1, 0.5, 1, 2, 5}, // 延迟分桶
    },
)

// 记录延迟
start := time.Now()
// ... 处理请求 ...
duration := time.Since(start).Seconds()
requestDuration.Observe(duration)
```

**Python 项目**:
```python
import time
import numpy as np

latencies = []
for _ in range(1000):
    start = time.time()
    # ... 处理请求 ...
    latency = (time.time() - start) * 1000  # ms
    latencies.append(latency)

# 计算百分位数
p50 = np.percentile(latencies, 50)
p95 = np.percentile(latencies, 95)
p99 = np.percentile(latencies, 99)
```

#### 优化策略

| 延迟问题 | 可能原因 | 优化方案 |
|----------|----------|----------|
| P50 高 | 代码效率低 | 算法优化、减少 DB 查询 |
| P95 高 | 缓存未命中 | 增加缓存预热、提高命中率 |
| P99 高 | GC 停顿、网络抖动 | 调优 GC、增加重试、超时控制 |
| P99.9 极高 | 冷启动、慢查询 | 连接池预热、优化慢 SQL |

---

## 第三部分: Throughput 与带宽估算

### 3.1 吞吐量计算

#### 定义
- **吞吐量 (Throughput)**: 单位时间内系统处理的数据量
- **单位**: MB/s, GB/s, requests/s

#### 公式

```
吞吐量 = 请求数/秒 × 单个请求大小

示例:
QPS = 1000
平均请求大小 = 10KB
吞吐量 = 1000 × 10KB = 10MB/s = 80Mbps
```

### 3.2 带宽估算实战

#### 案例 1: 图片分发服务

**需求**:
- DAU: 500 万
- 每个用户平均查看 50 张图片/天
- 图片平均大小: 200KB
- 峰值因子: 3倍

**计算**:

```
1. 日总流量 = 5,000,000 × 50 × 200KB
            = 50,000,000,000 KB
            = 50,000 GB/天
            ≈ 48.8 TB/天

2. 平均带宽 = 48.8 TB / 86,400秒
            = 48.8 × 1024 GB / 86,400
            = 50,000 GB / 86,400
            ≈ 0.579 GB/s
            ≈ 4.6 Gbps

3. 峰值带宽 = 4.6 Gbps × 3 ≈ 13.8 Gbps

4. 加上 20% 冗余 = 13.8 × 1.2 ≈ 16.6 Gbps
```

**成本估算** (AWS CloudFront):
- 前 10TB: $0.085/GB → $850
- 10TB-50TB: $0.080/GB → $3,200
- **月成本**: 约 $4,050 × 30天 ≈ **$121,500/月**

#### 案例 2: 视频流媒体

**需求**:
- 并发观看用户: 10,000
- 视频码率: 5 Mbps (1080p)

**计算**:

```
总带宽 = 10,000 × 5 Mbps = 50,000 Mbps = 50 Gbps
```

**优化方案**:
1. 使用 CDN 分发（就近访问）
2. 自适应码率（根据网速调整画质）
3. P2P 技术（用户互相分享）

### 3.3 常用数字速记

**必须记住的延迟数据** (Jeff Dean 的经典数据):

```
L1 缓存引用                0.5 ns
分支预测错误               5 ns
L2 缓存引用                7 ns
互斥锁加锁/解锁           25 ns
内存引用                 100 ns
用 Zippy 压缩 1K 字节     3 μs (3,000 ns)
通过 1Gbps 网络发送 1K   10 μs
从 SSD 随机读取 4K      150 μs
内存中顺序读取 1MB      250 μs
同一数据中心往返       500 μs
从 SSD 顺序读取 1MB      1 ms
磁盘寻道                10 ms
从磁盘顺序读取 1MB      20 ms
跨洋网络往返           150 ms
```

**带宽换算**:

```
1 Byte = 8 bits
1 KB = 1024 Bytes
1 MB = 1024 KB = 1,048,576 Bytes
1 GB = 1024 MB

1 Gbps (Gigabit per second) = 125 MB/s
1 Gbps 带宽理论上每秒传输 125MB 数据

实际问题:
Q: 1 Gbps 带宽每秒能传输多少张 1MB 的图片？
A: 125 MB/s ÷ 1 MB/张 = 125 张/秒

Q: 10 Gbps 带宽支持多少并发视频流（每个 5Mbps）？
A: 10,000 Mbps ÷ 5 Mbps = 2,000 个并发流
```

---

## 第四部分: Little's Law - 并发数估算

### 4.1 定理内容

**Little's Law (利特尔法则)**:

```
L = λ × W

其中:
L = 系统中的平均请求数 (并发数)
λ = 请求到达率 (QPS)
W = 请求在系统中的平均停留时间 (响应时间)
```

### 4.2 实际应用

#### 案例 1: 计算所需并发连接数

**已知**:
- QPS = 1,000
- 平均响应时间 = 100ms = 0.1s

**求**: 系统需要支持多少并发连接？

```
L = λ × W
L = 1000 × 0.1 = 100 个并发连接
```

**验证**:
- 如果有 100 个并发请求
- 每个请求耗时 0.1s
- 那么 1 秒内可以处理 100 / 0.1 = 1000 个请求 ✓

#### 案例 2: 反向计算响应时间

**已知**:
- 系统最多支持 500 个并发连接
- 目标 QPS = 2,000

**求**: 平均响应时间需要多快？

```
W = L / λ
W = 500 / 2000 = 0.25s = 250ms
```

**结论**: 如果响应时间超过 250ms，系统将无法支持 2000 QPS。

#### 案例 3: 数据库连接池设计

**已知**:
- 应用 QPS = 5,000
- 单个数据库查询平均耗时 = 10ms = 0.01s

**求**: 连接池需要多少连接？

```
L = λ × W
L = 5000 × 0.01 = 50 个连接
```

**实践建议**:
- 理论需要 50 个连接
- 考虑峰值和抖动，设置为 **80-100 个连接**
- 同时设置最大连接数防止资源耗尽

### 4.3 扩展应用

#### 排队论视角

如果响应时间包含排队等待时间:

```
W = W_service + W_queue

当系统负载接近 100% 时，W_queue 会急剧增加！
```

**示例**:
- 服务时间: 10ms
- 利用率 50%: 排队时间 ≈ 10ms → 总延迟 20ms
- 利用率 90%: 排队时间 ≈ 90ms → 总延迟 100ms
- 利用率 99%: 排队时间 ≈ 990ms → 总延迟 1000ms

**启示**: **永远不要让系统运行在 90% 以上利用率！**

---

## 第五部分: 容量规划方法论

### 5.1 自底向上估算法

#### 步骤 1: 功能需求分析

**示例: Twitter 类系统**

| 功能 | 读/写 | 频率估计 |
|------|-------|----------|
| 发推文 | 写 | 2 次/人/天 |
| 查看 Timeline | 读 | 100 次/人/天 |
| 点赞 | 写 | 5 次/人/天 |
| 搜索 | 读 | 10 次/人/天 |

#### 步骤 2: 用户规模估算

```
注册用户: 10 亿
月活用户 (MAU): 5 亿 (50%)
日活用户 (DAU): 2 亿 (40% of MAU)
```

#### 步骤 3: QPS 估算

**写 QPS (发推文)**:

```
每天新推文数 = 2亿 DAU × 2条/人 = 4亿条/天

平均写 QPS = 400,000,000 / 86,400 ≈ 4,630 QPS

峰值写 QPS = 4,630 × 3 ≈ 13,890 QPS
```

**读 QPS (Timeline)**:

```
每天 Timeline 请求 = 2亿 × 100次 = 200亿次/天

平均读 QPS = 20,000,000,000 / 86,400 ≈ 231,481 QPS

峰值读 QPS = 231,481 × 3 ≈ 694,444 QPS
```

**读写比**: 694,444 / 13,890 ≈ **50:1** (典型读多写少)

#### 步骤 4: 存储容量估算

**推文数据**:

```
单条推文大小:
- 文本 (280字 × 2 bytes UTF-8)  = 560 bytes
- 用户 ID (8 bytes)             = 8 bytes
- 时间戳 (8 bytes)              = 8 bytes
- 点赞数/转发数 (各 4 bytes)    = 8 bytes
- 其他元数据                    ≈ 100 bytes
总计                            ≈ 700 bytes ≈ 1KB (保守估计)

每天新增存储 = 4亿条 × 1KB = 400GB/天

5年存储 = 400GB × 365 × 5 = 730TB ≈ 0.73PB
```

**图片/视频**:

```
假设 20% 推文包含图片 (平均 200KB)
每天图片量 = 4亿 × 20% × 200KB = 16TB/天

5年存储 = 16TB × 365 × 5 = 29.2PB
```

**总存储 (含 3 副本)**:

```
文本: 0.73PB × 3 = 2.2PB
媒体: 29.2PB × 3 = 87.6PB
总计: ≈ 90PB
```

#### 步骤 5: 带宽估算

**写带宽**:

```
文本: 400GB / 86,400s ≈ 4.6MB/s ≈ 37Mbps
图片: 16TB / 86,400s ≈ 185MB/s ≈ 1.5Gbps
总写带宽 (峰值×3): 1.5Gbps × 3 ≈ 4.5Gbps
```

**读带宽**:

```
假设读写比 50:1
读带宽 = 4.5Gbps × 50 = 225Gbps

(实际会通过 CDN 分担，源站带宽需求会低很多)
```

#### 步骤 6: 服务器数量估算

**应用服务器** (处理业务逻辑):

```
假设单台服务器处理能力: 1,000 QPS
峰值 QPS: 694,444
需要服务器: 694,444 / 1,000 ≈ 695 台

考虑冗余 (N+2): 700 台
考虑跨机房 (3个机房): 700 × 3 = 2,100 台应用服务器
```

**数据库服务器** (MySQL):

```
主库 (写):
- 单台 MySQL 写能力: 5,000 TPS
- 峰值写 QPS: 13,890
- 需要主库: 13,890 / 5,000 ≈ 3 台 (分片)

从库 (读):
- 单台 MySQL 读能力: 10,000 QPS
- 峰值读 QPS: 694,444
- 需要从库: 694,444 / 10,000 ≈ 70 台

总计: 3 主 + 70 从 = 73 台 MySQL
(实际会用缓存减少 DB 压力)
```

**缓存服务器** (Redis):

```
假设缓存热数据 (20% 推文)
缓存数据量: 90PB × 20% = 18PB

单台 Redis: 256GB 内存
需要 Redis: 18PB / 256GB = 18,000,000 / 256 ≈ 70,000 台

优化后 (只缓存最近7天数据):
7天数据量: 16TB × 7 = 112TB
需要 Redis: 112TB / 256GB ≈ 450 台
```

#### 步骤 7: 成本估算

**服务器成本** (AWS EC2 c5.2xlarge, $0.34/h):

```
2,100 台应用服务器 × $0.34/h × 730h/月 = $520,380/月
```

**数据库成本** (RDS db.r5.4xlarge, $1.60/h):

```
73 台 × $1.60/h × 730h/月 = $85,264/月
```

**缓存成本** (ElastiCache r5.4xlarge, $1.34/h):

```
450 台 × $1.34/h × 730h/月 = $440,370/月
```

**存储成本** (S3, $0.023/GB/月):

```
90PB = 90,000,000 GB
90,000,000 × $0.023 = $2,070,000/月
```

**带宽成本** (CloudFront, $0.085/GB):

```
假设每月出流量: 225Gbps × 30天 × 86,400s / 8 / 1024 / 1024 / 1024
= 225 × 30 × 86,400 / 8 / 1024 / 1024 / 1024 GB
≈ 7,000,000 GB/月

7,000,000 × $0.085 = $595,000/月
```

**总成本**:

```
服务器: $520,380
数据库: $85,264
缓存: $440,370
存储: $2,070,000
带宽: $595,000
─────────────────
总计: $3,711,014/月 ≈ $3.7M/月
```

### 5.2 实践项目: Twitter 容量规划

请完成以下练习（见 DAILY_CHECKLIST.md 第 217-296 行）:

1. **需求分析**: 确定功能范围和用户规模
2. **流量估算**: 计算读/写 QPS
3. **存储估算**: 计算文本、图片、视频存储需求
4. **带宽估算**: 计算入/出带宽
5. **服务器估算**: 应用服务器、数据库、缓存数量
6. **成本估算**: 总 TCO 计算

**输出成果**:
- Excel 容量规划表
- 架构图 (标注服务器数量、存储、带宽)
- 成本预算报告

---

## 第六部分: 实战练习

### 练习 1: QPS 计算

某电商网站有以下数据:
- DAU: 50 万
- 每个用户平均访问 30 个页面/天
- 高峰时段 (2 小时) 占全天流量的 40%
- 峰值因子: 4 倍

**问题**:
1. 平均 QPS 是多少？
2. 高峰时段平均 QPS？
3. 瞬时峰值 QPS？
4. 如果单台 Nginx 处理 5000 QPS，需要几台？

### 练习 2: 延迟分析

以下是 100 次 API 请求的响应时间 (ms):
```
[5, 8, 10, 12, 15, 18, 20, 22, 25, 28,
 30, 32, 35, 38, 40, 42, 45, 48, 50, 55,
 ... (省略中间数据) ...
 200, 250, 300, 500, 1000]
```

**问题**:
1. 计算 P50、P95、P99
2. 如果 SLA 要求 P95 < 100ms，是否达标？
3. 如果微服务链路中有 5 个这样的服务，整体 P95 会是多少？

### 练习 3: Little's Law

一个数据库连接池有以下配置:
- 最大连接数: 200
- 平均每个查询耗时: 20ms

**问题**:
1. 理论最大 QPS 是多少？
2. 如果实际 QPS 只有 5,000，说明什么？
3. 如果要支持 10,000 QPS，需要调整什么？

### 练习 4: 容量规划

为一个短视频 APP 做容量规划:
- DAU: 1000 万
- 每个用户平均上传 2 个视频/天 (平均 50MB)
- 每个用户平均观看 30 个视频/天
- 视频平均码率: 3Mbps (375KB/s)
- 平均观看时长: 60 秒

**问题**:
1. 每天新增存储需求？
2. 存储 1 年需要多少 PB？
3. 峰值带宽需求 (假设 10 万并发观看)？
4. 估算 CDN 月成本 (CloudFront $0.085/GB)

---

## 第七部分: 学习资源

### 必读文章

1. **[AWS: Using Load Testing to Scale](https://aws.amazon.com/builders-library/using-load-testing-to-ensure-that-your-service-can-scale/)**
   - 如何通过压测验证容量规划

2. **[Brendan Gregg: The USE Method](https://www.brendangregg.com/usemethod.html)**
   - 系统性能分析方法论

3. **[Numbers Every Programmer Should Know](https://gist.github.com/jboner/2841832)**
   - 必须记住的延迟数据

4. **[Little's Law on Wikipedia](https://en.wikipedia.org/wiki/Little%27s_law)**
   - Little's Law 理论基础

### 推荐书籍

1. **《Site Reliability Engineering》 - Google SRE Book**
   - Chapter 4: Service Level Objectives
   - Chapter 6: Monitoring Distributed Systems

2. **《Designing Data-Intensive Applications》**
   - Appendix: Little's Law 应用

3. **[Systems Performance](https://raw.githubusercontent.com/samlee2015jp/cs_books/main/Systems.Performance.Enterprise.and.the.Cloud.2nd.Edition.2020.12.pdf) - Brendan Gregg**
   - 性能分析的圣经

### 在线工具

1. **[System Design Calculator](https://bytebytego.com/capacity-estimation)**
   - 容量规划计算器

2. **[AWS Pricing Calculator](https://calculator.aws/)**
   - 云成本估算

3. **[Latency Numbers Visualized](https://colin-scott.github.io/personal_website/research/interactive_latency.html)**
   - 延迟数据可视化

---

## 学习检查清单

完成以下任务后，可认为本模块学习完成:

- [ ] 能解释 QPS 和 TPS 的区别，并举出实际例子
- [ ] 能手工计算给定数据集的 P50、P95、P99
- [ ] 理解为什么 P99 比平均值更重要
- [ ] 记住 Jeff Dean 的常用延迟数字 (至少 10 个)
- [ ] 能使用 Little's Law 计算并发数/响应时间/QPS 的关系
- [ ] 完成至少 1 个完整的容量规划案例 (Twitter 或自选系统)
- [ ] 输出 Excel 容量规划表和架构图
- [ ] 能估算云服务成本 (至少了解 AWS 定价)

---

## 下一步

完成本模块后，继续学习:
1. **Week 1 总结**: 回顾负载均衡、容量规划所有内容
2. **Week 2**: 存储系统原理 (RDBMS、NoSQL)

**记得记录学习笔记**: `notes/week1/module3-capacity-planning.md`

祝学习顺利! 🚀
