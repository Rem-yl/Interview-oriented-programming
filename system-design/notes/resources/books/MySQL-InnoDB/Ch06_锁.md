# Ch06 锁

锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问，保证数据的一致性和完整性。

## 锁的概述

### 什么是锁？

```mermaid
graph TB
    Start[多个事务并发访问] --> Lock[锁机制]
    Lock --> Control[控制访问顺序]
    Control --> Goal1[保证数据一致性]
    Control --> Goal2[提高并发性能]

    style Lock fill:#87CEEB
    style Goal1 fill:#90EE90
    style Goal2 fill:#90EE90
```

**锁的核心作用**：

| 作用 | 说明 | 示例 |
|------|------|------|
| 并发控制 | 协调多个事务对同一资源的访问 | 两个事务同时修改同一行 |
| 数据一致性 | 防止脏读、不可重复读、幻读 | 事务隔离级别的实现基础 |
| 性能优化 | 合适的锁粒度提高并发度 | 行锁比表锁并发度更高 |

---

## InnoDB中的锁

### 锁的分类

```mermaid
graph TB
    InnoDB[InnoDB锁机制] --> Level[按锁粒度分类]
    InnoDB --> Type[按锁类型分类]
    InnoDB --> Purpose[按锁目的分类]

    Level --> Table[表级锁]
    Level --> Row[行级锁]

    Type --> Shared[共享锁S]
    Type --> Exclusive[排他锁X]

    Purpose --> Intent[意向锁]
    Purpose --> Record[记录锁]
    Purpose --> Gap[间隙锁]
    Purpose --> NextKey[Next-Key锁]

    style Table fill:#FFD700
    style Row fill:#90EE90
    style Shared fill:#87CEEB
    style Exclusive fill:#FF6B6B
```

---

### 共享锁与排他锁

**锁兼容性矩阵**：

```mermaid
graph TB
    subgraph 当前持有的锁
    A1[共享锁 S]
    A2[排他锁 X]
    end

    subgraph 请求的锁
    B1[共享锁 S]
    B2[排他锁 X]
    end

    A1 -.兼容✅.-> B1
    A1 -.不兼容❌.-> B2
    A2 -.不兼容❌.-> B1
    A2 -.不兼容❌.-> B2

    style A1 fill:#87CEEB
    style B1 fill:#87CEEB
    style A2 fill:#FF6B6B
    style B2 fill:#FF6B6B
```

**锁兼容性表**：

|  | 共享锁(S) | 排他锁(X) |
|--|-----------|-----------|
| **共享锁(S)** | ✅ 兼容 | ❌ 不兼容 |
| **排他锁(X)** | ❌ 不兼容 | ❌ 不兼容 |

**使用场景**：

```
-- 共享锁（读锁）
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;
或
SELECT * FROM users WHERE id = 1 FOR SHARE;

-- 排他锁（写锁）
SELECT * FROM users WHERE id = 1 FOR UPDATE;
```

---

### 意向锁（Intention Lock）

**问题场景**：如何高效判断表级锁是否可以被获取？

```mermaid
sequenceDiagram
    participant T1 as 事务1
    participant Table as 表级锁
    participant Row as 行级锁
    participant T2 as 事务2

    Note over T1,T2: 无意向锁的问题

    T1->>Row: 获取行级X锁
    Note over Row: 锁定某一行

    T2->>Table: 请求表级X锁
    Note over T2: 需要扫描所有行<br/>检查是否有行锁<br/>效率极低！

    Note over T1,T2: 使用意向锁的解决方案

    T1->>Table: 先获取IX意向锁
    T1->>Row: 再获取行级X锁

    T2->>Table: 请求表级X锁
    Note over Table: 检查IX锁存在<br/>立即知道有行锁<br/>阻塞或拒绝
```

**意向锁类型**：

| 意向锁 | 全称 | 含义 | 与表级锁兼容性 |
|--------|------|------|---------------|
| **IS** | Intention Shared | 事务想要获取表中某些行的S锁 | 与S兼容，与X不兼容 |
| **IX** | Intention Exclusive | 事务想要获取表中某些行的X锁 | 只与IS兼容 |

**完整兼容性矩阵**：

|  | IS | IX | S | X |
|--|----|----|---|---|
| **IS** | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ |
| **S**  | ✅ | ❌ | ✅ | ❌ |
| **X**  | ❌ | ❌ | ❌ | ❌ |

---

## 锁的算法

### InnoDB的三种行锁算法

```mermaid
graph TB
    RowLock[InnoDB行锁算法] --> RecordLock[记录锁<br/>Record Lock]
    RowLock --> GapLock[间隙锁<br/>Gap Lock]
    RowLock --> NextKeyLock[Next-Key Lock]

    RecordLock --> R1[锁定单个索引记录]
    GapLock --> G1[锁定索引记录间隙<br/>不包含记录本身]
    NextKeyLock --> N1[记录锁 + 间隙锁<br/>左开右闭区间]

    style RecordLock fill:#87CEEB
    style GapLock fill:#FFD700
    style NextKeyLock fill:#90EE90
```

---

### Record Lock（记录锁）

**核心特点**：锁定单个索引记录。

```mermaid
graph LR
    subgraph 索引
    I1[10]
    I2[20]
    I3[30]
    I4[40]
    end

    I2 --> Lock[🔒 锁定记录20]

    style I2 fill:#FF6B6B
    style Lock fill:#FF6B6B
```

**示例场景**：

```
-- 表结构
CREATE TABLE t (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

-- 数据：id = 10, 20, 30, 40

-- 事务1
BEGIN;
SELECT * FROM t WHERE id = 20 FOR UPDATE;
-- 锁定：记录id=20
```

**特点**：
- 总是锁定索引记录
- 如果表没有索引，InnoDB会创建隐藏的聚簇索引并对其加锁

---

### Gap Lock（间隙锁）

**核心特点**：锁定索引记录之间的间隙，防止其他事务插入数据。

```mermaid
graph LR
    subgraph 索引
    I1[10]
    Gap1[间隙1]
    I2[20]
    Gap2[间隙2]
    I3[30]
    Gap3[间隙3]
    I4[40]
    end

    Gap2 --> Lock[🔒 锁定间隙<br/>20-30之间]

    style Gap2 fill:#FFD700
    style Lock fill:#FFD700
```

**作用**：防止幻读

```mermaid
sequenceDiagram
    participant T1 as 事务1<br/>(REPEATABLE READ)
    participant DB as 数据库<br/>id: 10,20,30,40
    participant T2 as 事务2

    T1->>DB: SELECT * FROM t WHERE id > 20 FOR UPDATE
    Note over DB: 锁定间隙: (20,30], (30,40], (40,+∞)

    T2->>DB: INSERT INTO t VALUES (25, 'new')
    Note over T2: 被阻塞！<br/>25在间隙(20,30)内

    T2->>DB: INSERT INTO t VALUES (15, 'new')
    Note over T2: 成功<br/>15不在锁定间隙内
```

**重要特性**：

| 特性 | 说明 |
|------|------|
| 隔离级别 | 只在REPEATABLE READ及以上级别生效 |
| 锁定范围 | 开区间，不包含端点记录 |
| 目的 | 防止幻读（Phantom Read） |
| 性能影响 | 降低并发插入性能 |

---

### Next-Key Lock

**核心特点**：Record Lock + Gap Lock，锁定一个范围（左开右闭区间）。

```mermaid
graph LR
    subgraph 索引
    I1[10]
    Gap1[间隙]
    I2[20]
    Gap2[间隙]
    I3[30]
    Gap3[间隙]
    I4[40]
    end

    Gap2 --> Lock[🔒 Next-Key Lock<br/>锁定范围: 20,30]
    I3 --> Lock

    style Gap2 fill:#FFD700
    style I3 fill:#FF6B6B
    style Lock fill:#90EE90
```

**Next-Key Lock范围示例**：

假设索引有值：10, 20, 30, 40

| 查询条件 | 锁定的Next-Key Lock范围 |
|---------|------------------------|
| `WHERE id = 20` | (10, 20] |
| `WHERE id > 20` | (20, 30], (30, 40], (40, +∞) |
| `WHERE id >= 20 AND id < 40` | (10, 20], (20, 30], (30, 40) |

**工作原理**：

```mermaid
graph TB
    Query[查询: SELECT * WHERE id > 20 FOR UPDATE] --> Analyze[分析索引]
    Analyze --> Range[确定扫描范围]
    Range --> Lock1[锁定: 20,30]
    Range --> Lock2[锁定: 30,40]
    Range --> Lock3[锁定: 40,+∞]

    Lock1 --> Prevent[防止插入id在20-30之间的记录]
    Lock2 --> Prevent
    Lock3 --> Prevent

    style Query fill:#87CEEB
    style Prevent fill:#90EE90
```

**降级为Record Lock的情况**：

```
-- 当使用唯一索引精确匹配时，Next-Key Lock降级为Record Lock

-- 索引：PRIMARY KEY (id)
-- 数据：id = 10, 20, 30, 40

-- 查询1：唯一索引等值查询，记录存在
SELECT * FROM t WHERE id = 20 FOR UPDATE;
-- 锁定：Record Lock on id=20

-- 查询2：唯一索引等值查询，记录不存在
SELECT * FROM t WHERE id = 25 FOR UPDATE;
-- 锁定：Gap Lock (20, 30)

-- 查询3：非唯一索引或范围查询
SELECT * FROM t WHERE id > 20 FOR UPDATE;
-- 锁定：Next-Key Lock (20,30], (30,40], (40,+∞)
```

---

## 锁问题

### 脏读（Dirty Read）

**问题**：读取到其他事务未提交的数据。

```mermaid
sequenceDiagram
    participant T1 as 事务1
    participant DB as 数据库<br/>balance=1000
    participant T2 as 事务2

    T1->>DB: BEGIN
    T1->>DB: UPDATE balance=500
    Note over DB: 未提交: balance=500

    T2->>DB: BEGIN (READ UNCOMMITTED)
    T2->>DB: SELECT balance
    Note over T2: 读到500（脏读！）

    T1->>DB: ROLLBACK
    Note over DB: 回滚: balance=1000

    Note over T2: T2读到的500是无效数据
```

**解决方案**：使用READ COMMITTED或更高隔离级别。

---

### 不可重复读（Non-Repeatable Read）

**问题**：同一事务内，多次读取同一数据返回不同结果。

```mermaid
sequenceDiagram
    participant T1 as 事务1
    participant DB as 数据库<br/>balance=1000
    participant T2 as 事务2

    T1->>DB: BEGIN (READ COMMITTED)
    T1->>DB: SELECT balance
    Note over T1: 读到1000

    T2->>DB: BEGIN
    T2->>DB: UPDATE balance=500
    T2->>DB: COMMIT
    Note over DB: balance=500

    T1->>DB: SELECT balance
    Note over T1: 读到500（不可重复读！）
```

**解决方案**：使用REPEATABLE READ隔离级别（InnoDB默认）。

---

### 幻读（Phantom Read）

**问题**：同一事务内，范围查询时发现新插入的数据。

```mermaid
sequenceDiagram
    participant T1 as 事务1
    participant DB as 数据库<br/>id: 10,30,50
    participant T2 as 事务2

    T1->>DB: BEGIN (REPEATABLE READ)
    T1->>DB: SELECT COUNT(*) WHERE id > 10
    Note over T1: 返回2条（id=30,50）

    T2->>DB: BEGIN
    T2->>DB: INSERT INTO t VALUES (20)
    T2->>DB: COMMIT

    T1->>DB: SELECT COUNT(*) WHERE id > 10
    Note over T1: 仍返回2条（MVCC防止幻读）

    T1->>DB: UPDATE t SET name='x' WHERE id > 10
    Note over DB: 影响3行！包括id=20<br/>（当前读，出现幻读）
```

**InnoDB的防幻读机制**：

| 操作类型 | 机制 | 能否防止幻读 |
|---------|------|-------------|
| 快照读 | MVCC（多版本并发控制） | ✅ 能防止 |
| 当前读 | Next-Key Lock | ✅ 能防止 |

```
-- 快照读（使用MVCC）
SELECT * FROM t WHERE id > 10;

-- 当前读（使用Next-Key Lock）
SELECT * FROM t WHERE id > 10 FOR UPDATE;
SELECT * FROM t WHERE id > 10 LOCK IN SHARE MODE;
UPDATE t SET name = 'x' WHERE id > 10;
DELETE FROM t WHERE id > 10;
```

---

### 丢失更新（Lost Update）

**问题场景对比**：

```mermaid
graph TB
    subgraph 问题：丢失更新
    A1[事务1读取balance=100] --> A2[事务1计算: 100+50=150]
    B1[事务2读取balance=100] --> B2[事务2计算: 100-30=70]
    A2 --> A3[事务1写入150]
    B2 --> B3[事务2写入70]
    A3 --> Result1[最终: 70<br/>事务1的+50丢失!]
    B3 --> Result1
    end

    subgraph 解决方案
    C1[事务1: SELECT FOR UPDATE] --> C2[获取排他锁<br/>balance=100]
    C2 --> C3[事务2被阻塞]
    C2 --> C4[事务1更新为150并提交]
    C4 --> C5[事务1释放锁]
    C5 --> C6[事务2获得锁<br/>读到150]
    C6 --> C7[事务2更新为120并提交]
    C7 --> Result2[最终: 120<br/>两个更新都生效✅]
    end

    style Result1 fill:#FF6B6B
    style Result2 fill:#90EE90
```

**解决方案对比**：

| 方案 | SQL示例 | 优点 | 缺点 |
|------|---------|------|------|
| 显式加锁 | `SELECT ... FOR UPDATE` | 简单可靠 | 性能较差 |
| 乐观锁 | 使用version字段 | 性能好 | 需要重试逻辑 |
| 原子操作 | `UPDATE balance=balance+50` | 最优 | 仅适用简单场景 |

---

## 死锁

### 死锁产生的原因

```mermaid
sequenceDiagram
    participant T1 as 事务1
    participant R1 as 资源1<br/>(row id=1)
    participant R2 as 资源2<br/>(row id=2)
    participant T2 as 事务2

    Note over T1,T2: 时刻1
    T1->>R1: 请求X锁（成功）
    T2->>R2: 请求X锁（成功）

    Note over T1,T2: 时刻2
    T1->>R2: 请求X锁（等待T2释放）
    Note over T1: 阻塞中...

    T2->>R1: 请求X锁（等待T1释放）
    Note over T2: 阻塞中...

    Note over T1,T2: 形成循环等待 = 死锁！
```

**死锁的四个必要条件**：

```mermaid
graph TB
    Deadlock[死锁发生] --> C1[互斥条件<br/>资源不能共享]
    Deadlock --> C2[请求与保持<br/>持有资源再请求]
    Deadlock --> C3[不可剥夺<br/>不能强制释放]
    Deadlock --> C4[循环等待<br/>形成等待环]

    Break[破坏任一条件<br/>即可预防死锁]

    C1 -.-> Break
    C2 -.-> Break
    C3 -.-> Break
    C4 -.-> Break

    style Deadlock fill:#FF6B6B
    style Break fill:#90EE90
```

---

### InnoDB的死锁检测

```mermaid
graph TB
    Start[事务请求锁] --> Check{锁是否可用?}

    Check -->|是| Grant[授予锁]
    Check -->|否| Wait[加入等待队列]

    Wait --> Detect[死锁检测算法<br/>Wait-for Graph]

    Detect --> IsDeadlock{检测到死锁?}

    IsDeadlock -->|否| Continue[继续等待]
    IsDeadlock -->|是| ChooseVictim[选择牺牲者<br/>回滚代价最小的事务]

    ChooseVictim --> Rollback[回滚事务]
    Rollback --> Error[返回错误:<br/>ERROR 1213 Deadlock]

    style Detect fill:#87CEEB
    style Rollback fill:#FF6B6B
    style Grant fill:#90EE90
```

**死锁检测参数**：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `innodb_deadlock_detect` | ON | 是否开启死锁检测 |
| `innodb_lock_wait_timeout` | 50秒 | 锁等待超时时间 |

**查看死锁信息**：

```sql
-- 查看最近一次死锁信息
SHOW ENGINE INNODB STATUS;

-- 启用死锁日志
SET GLOBAL innodb_print_all_deadlocks = ON;
```

---

### 死锁示例

**示例1：经典死锁**

```
-- 会话1
BEGIN;
UPDATE t SET name='a' WHERE id=1;  -- 获取id=1的X锁
-- 等待...
UPDATE t SET name='a' WHERE id=2;  -- 尝试获取id=2的X锁（等待会话2）

-- 会话2
BEGIN;
UPDATE t SET name='b' WHERE id=2;  -- 获取id=2的X锁
UPDATE t SET name='b' WHERE id=1;  -- 尝试获取id=1的X锁（等待会话1）
-- ERROR 1213: Deadlock found when trying to get lock
```

**示例2：间隙锁死锁**

```
-- 表结构和数据
CREATE TABLE t (id INT PRIMARY KEY, name VARCHAR(10));
INSERT INTO t VALUES (10, 'a'), (30, 'c');

-- 会话1
BEGIN;
SELECT * FROM t WHERE id = 20 FOR UPDATE;  -- Gap Lock (10,30)

-- 会话2
BEGIN;
SELECT * FROM t WHERE id = 25 FOR UPDATE;  -- Gap Lock (10,30)，兼容

-- 会话1
INSERT INTO t VALUES (20, 'b');  -- 等待会话2的Gap Lock

-- 会话2
INSERT INTO t VALUES (25, 'd');  -- 等待会话1的Gap Lock
-- ERROR 1213: Deadlock found
```

---

### 避免死锁的策略

```mermaid
graph TB
    Strategy[避免死锁策略] --> S1[应用层设计]
    Strategy --> S2[数据库配置]
    Strategy --> S3[SQL优化]

    S1 --> S1A[按固定顺序访问资源]
    S1 --> S1B[缩短事务时间]
    S1 --> S1C[降低事务隔离级别]

    S2 --> S2A[调整锁等待超时]
    S2 --> S2B[启用死锁检测]

    S3 --> S3A[使用索引减少锁范围]
    S3 --> S3B[减少间隙锁使用]
    S3 --> S3C[拆分大事务]

    style S1 fill:#90EE90
    style S2 fill:#87CEEB
    style S3 fill:#FFD700
```

**最佳实践**：

| 策略 | 具体措施 | 效果 |
|------|---------|------|
| 按顺序加锁 | 多个资源按id排序后加锁 | 破坏循环等待条件 |
| 快速提交 | 减少事务持有锁的时间 | 降低死锁概率 |
| 使用索引 | 避免全表扫描导致的锁升级 | 减少锁范围 |
| 降低隔离级别 | 使用READ COMMITTED | 减少间隙锁 |
| 批量操作分批 | 大批量操作分多次执行 | 减少锁冲突 |

---

## 锁升级

**什么是锁升级？**

```mermaid
graph LR
    Start[大量行锁] --> Threshold{超过阈值?}
    Threshold -->|否| Keep[保持行锁]
    Threshold -->|是| Upgrade[升级为表锁]

    Upgrade --> Problem[问题: 降低并发度]

    style Start fill:#87CEEB
    style Upgrade fill:#FF6B6B
    style Problem fill:#FF6B6B
```

**InnoDB vs SQL Server**：

| 数据库 | 是否支持锁升级 | 说明 |
|--------|--------------|------|
| **SQL Server** | ✅ 支持 | 行锁数量超过阈值时自动升级为表锁 |
| **InnoDB** | ❌ 不支持 | 根据事务访问的每个页加锁，锁粒度固定 |

**InnoDB不支持锁升级的原因**：

- 使用位图管理锁，内存占用少
- 不需要通过锁升级来节省内存
- 保持稳定的并发性能

---

## 锁监控与诊断

### 查看锁信息

```sql
-- 查看当前锁等待情况（MySQL 8.0+）
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;

-- 查看事务信息
SELECT * FROM information_schema.INNODB_TRX;

-- 查看锁等待信息（旧版本）
SELECT * FROM information_schema.INNODB_LOCKS;
SELECT * FROM information_schema.INNODB_LOCK_WAITS;

-- 查看InnoDB引擎状态
SHOW ENGINE INNODB STATUS;
```

### 锁等待分析流程

```mermaid
graph TB
    Start[发现性能问题] --> Check1[查看锁等待]
    Check1 --> Query1[查询data_lock_waits表]

    Query1 --> Identify[识别阻塞事务]
    Identify --> Analyze[分析SQL语句]

    Analyze --> Decision{是否长事务?}
    Decision -->|是| Kill[终止事务<br/>KILL thread_id]
    Decision -->|否| Optimize[优化SQL<br/>添加索引]

    Optimize --> Monitor[持续监控]
    Kill --> Monitor

    style Check1 fill:#87CEEB
    style Kill fill:#FF6B6B
    style Optimize fill:#90EE90
```

---

## 隔离级别与锁的关系

### 四种隔离级别对比

```mermaid
graph TB
    subgraph READ UNCOMMITTED
    RU[不加锁<br/>可能脏读]
    end

    subgraph READ COMMITTED
    RC[记录锁<br/>不锁间隙]
    end

    subgraph REPEATABLE READ
    RR[Next-Key Lock<br/>默认级别]
    end

    subgraph SERIALIZABLE
    S[所有读加共享锁<br/>严格串行]
    end

    RU --> RC --> RR --> S

    Note1[并发性能 ⬇] --> Note2[数据一致性 ⬆]

    style RU fill:#FF6B6B
    style RC fill:#FFD700
    style RR fill:#90EE90
    style S fill:#87CEEB
```

**隔离级别与锁对比表**：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 加锁方式 | 间隙锁 |
|---------|------|-----------|------|---------|-------|
| READ UNCOMMITTED | ❌ | ❌ | ❌ | 几乎不加锁 | ❌ |
| READ COMMITTED | ✅ | ❌ | ❌ | 记录锁 | ❌ |
| REPEATABLE READ | ✅ | ✅ | ✅ | Next-Key Lock | ✅ |
| SERIALIZABLE | ✅ | ✅ | ✅ | 所有读加锁 | ✅ |

**查看和设置隔离级别**：

```sql
-- 查看全局隔离级别
SELECT @@global.transaction_isolation;

-- 查看会话隔离级别
SELECT @@transaction_isolation;

-- 设置会话隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

## 核心要点总结

### 锁的本质

```mermaid
graph LR
    A[并发控制需求] --> B[锁机制]
    B --> C[数据一致性]
    B --> D[高并发性能]

    style B fill:#87CEEB
    style C fill:#90EE90
    style D fill:#90EE90
```

### InnoDB锁机制核心

**锁类型层次**：

```
表级
├── 意向共享锁 (IS)
├── 意向排他锁 (IX)
├── 表级共享锁 (S)
└── 表级排他锁 (X)

行级
├── 记录锁 (Record Lock) - 锁定索引记录
├── 间隙锁 (Gap Lock) - 锁定间隙，防止插入
└── Next-Key Lock - 记录锁+间隙锁，防止幻读
```

### 关键决策树

```mermaid
graph TD
    Start[遇到并发问题] --> Q1{需要什么隔离级别?}

    Q1 -->|读未提交| L1[READ UNCOMMITTED<br/>几乎不加锁]
    Q1 -->|读已提交| L2[READ COMMITTED<br/>记录锁，无间隙锁]
    Q1 -->|可重复读| L3[REPEATABLE READ<br/>Next-Key Lock]
    Q1 -->|串行化| L4[SERIALIZABLE<br/>最严格]

    L3 --> Q2{是否有幻读问题?}
    Q2 -->|是| Keep[使用Next-Key Lock]
    Q2 -->|否| Consider[考虑降级到RC<br/>提高并发]

    style L3 fill:#90EE90
    style Keep fill:#87CEEB
    style Consider fill:#FFD700
```

### 设计建议

1. **合理选择隔离级别**：大多数场景REPEATABLE READ足够
2. **利用索引**：减少锁的范围，避免全表扫描
3. **控制事务大小**：小事务减少锁持有时间
4. **按顺序加锁**：避免死锁
5. **监控锁等待**：及时发现和优化锁冲突

### 性能优化权衡

| 优化目标 | 措施 | 代价 |
|---------|------|------|
| 提高并发 | 降低隔离级别到RC | 可能出现幻读 |
| 防止幻读 | 使用RR + Next-Key Lock | 降低插入并发 |
| 减少死锁 | 缩短事务、按序加锁 | 增加应用复杂度 |
| 快速响应 | 设置锁等待超时 | 需要重试逻辑 |
