# 数据结构与算法必知必会全景图谱

> 系统学习后端开发、系统设计、分布式系统的核心数据结构与算法

本文档分为**数据结构**和**算法**两大部分，系统地整理了软件工程领域必须掌握的核心知识，包括原理、复杂度、应用场景和真实案例。

---

## 文档导航

### 📦 [第一部分：数据结构](#第一部分数据结构)
1. [基础数据结构](#1-基础数据结构)
2. [树形结构](#2-树形结构)
3. [哈希结构](#3-哈希结构)
4. [堆结构](#4-堆结构)
5. [图结构](#5-图结构)
6. [高级数据结构](#6-高级数据结构)

### 🔧 [第二部分：算法](#第二部分算法)
7. [排序算法](#7-排序算法)
8. [搜索算法](#8-搜索算法)
9. [字符串算法](#9-字符串算法)
10. [图算法](#10-图算法)
11. [动态规划](#11-动态规划)
12. [贪心算法](#12-贪心算法)
13. [分治算法](#13-分治算法)
14. [回溯算法](#14-回溯算法)
15. [数学算法](#15-数学算法)
16. [位运算技巧](#16-位运算技巧)
17. [压缩算法](#17-压缩算法)
18. [哈希算法](#18-哈希算法)
19. [加密算法](#19-加密算法)
20. [缓存淘汰算法](#20-缓存淘汰算法)
21. [分布式系统算法](#21-分布式系统算法)
22. [负载均衡算法](#22-负载均衡算法)
23. [限流算法](#23-限流算法)
24. [一致性算法](#24-一致性算法)

---

# 第一部分：数据结构

## 1. 基础数据结构

### 1.1 数组 (Array)

**原理**: 连续内存空间存储相同类型元素，通过索引随机访问。

**复杂度**:
- 访问: O(1)
- 插入/删除（末尾）: O(1)
- 插入/删除（中间）: O(n)
- 搜索: O(n) (未排序), O(log n) (已排序+二分)

**应用场景**:
- 需要快速随机访问的场景
- 作为其他数据结构的基础（栈、堆、哈希表）
- 动态数组（Go slice, Java ArrayList, C++ vector）

**优缺点**:
- ✅ 随机访问 O(1)
- ✅ 缓存友好（连续内存）
- ❌ 固定大小（静态数组）
- ❌ 插入/删除慢（需移动元素）

**真实案例**:
- Go slice 底层实现
- Redis List (ziplist 编码时)
- MySQL InnoDB 页内数据存储

**进阶技巧**:
- 双指针技巧
- 滑动窗口
- 前缀和/差分数组

---

### 1.2 链表 (Linked List)

**原理**: 通过指针将节点串联，每个节点包含数据和指向下一个节点的指针。

**类型**:
- **单链表**: 单向指针
- **双链表**: 双向指针，可双向遍历
- **循环链表**: 尾节点指向头节点

**复杂度**:
- 访问: O(n)
- 插入/删除（已知位置）: O(1)
- 搜索: O(n)

**应用场景**:
- 频繁插入/删除的场景
- LRU Cache 实现（双链表）
- 内存分配器（free list）

**优缺点**:
- ✅ 动态大小
- ✅ 插入/删除 O(1)
- ❌ 随机访问慢
- ❌ 额外指针空间
- ❌ 缓存不友好

**真实案例**:
- Linux 内核双链表
- Java LinkedList
- LRU Cache 实现

**常见操作**:
- 反转链表
- 检测环（Floyd Cycle Detection）
- 找中间节点（快慢指针）
- 合并有序链表

---

### 1.3 栈 (Stack)

**原理**: LIFO (Last In First Out) 后进先出，只能在栈顶操作。

**复杂度**:
- Push: O(1)
- Pop: O(1)
- Peek: O(1)

**应用场景**:
- 函数调用栈
- 表达式求值
- 括号匹配
- DFS 遍历
- 浏览器历史记录（后退）

**实现方式**:
- 数组实现（Go）
- 链表实现

**优缺点**:
- ✅ 简单高效
- ✅ 适合递归转迭代
- ❌ 只能访问栈顶

**真实案例**:
- JVM 方法调用栈
- 编译器语法分析
- 计算器实现

**经典问题**:
- 最小栈（O(1) 获取最小值）
- 单调栈（下一个更大元素）
- 有效括号匹配

---

### 1.4 队列 (Queue)

**原理**: FIFO (First In First Out) 先进先出。

**类型**:
- **普通队列**: 单端入队，单端出队
- **循环队列**: 使用数组实现，避免空间浪费
- **双端队列 (Deque)**: 两端都可入队/出队
- **优先队列**: 按优先级出队（通常用堆实现）

**复杂度**:
- Enqueue/Dequeue: O(1)

**应用场景**:
- BFS 遍历
- 任务调度
- 消息队列
- 缓冲区

**优缺点**:
- ✅ FIFO 语义清晰
- ✅ 适合生产者-消费者模型
- ❌ 随机访问慢

**真实案例**:
- Kafka 消息队列
- Redis List (LPUSH + RPOP)
- Linux 进程调度队列

**双端队列应用**:
- 滑动窗口最大值（单调队列）
- LRU Cache
- 工作窃取算法（Go runtime）

---

## 2. 树形结构

### 2.1 二叉搜索树 (BST)

**原理**: 左子树所有节点 < 根节点 < 右子树所有节点。

**复杂度**:
- 查找/插入/删除: O(log n) 平均, O(n) 最坏（退化为链表）
- 空间: O(n)

**应用场景**:
- 有序数据维护
- 范围查询
- 作为其他树的基础（AVL, 红黑树）

**优缺点**:
- ✅ 插入/删除/查找平均 O(log n)
- ✅ 中序遍历得到有序序列
- ❌ 最坏退化为链表
- ❌ 不自平衡

**遍历方式**:
- 前序: 根-左-右
- 中序: 左-根-右（有序）
- 后序: 左-右-根
- 层序: BFS

**经典问题**:
- 验证 BST
- 第 K 小元素
- BST 转双向链表

---

### 2.2 AVL 树

**原理**: 自平衡 BST，任意节点的左右子树高度差 ≤ 1。

**复杂度**:
- 查找/插入/删除: O(log n)
- 空间: O(n)

**平衡操作**:
- LL 旋转（右旋）
- RR 旋转（左旋）
- LR 旋转（先左后右）
- RL 旋转（先右后左）

**应用场景**:
- 查找密集型应用
- 需要严格平衡的场景
- Windows NT 内核（早期）

**优缺点**:
- ✅ 严格平衡，查找最快
- ✅ 最坏 O(log n)
- ❌ 插入/删除调整频繁
- ❌ 实现复杂

**对比红黑树**:
- AVL 更平衡 → 查找更快
- 红黑树插入删除更快 → 适合修改多的场景

---

### 2.3 红黑树 (Red-Black Tree)

**原理**: 自平衡 BST，通过颜色标记和旋转保持平衡。

**五条性质**:
1. 节点是红色或黑色
2. 根节点是黑色
3. 叶节点（NIL）是黑色
4. 红色节点的子节点必须是黑色
5. 从根到叶的所有路径包含相同数量的黑色节点

**复杂度**:
- 查找/插入/删除: O(log n)
- 空间: O(n)

**应用场景**:
- C++ STL (map, set)
- Java TreeMap, TreeSet
- Linux 进程调度 (CFS)
- Nginx Timer 管理

**优缺点**:
- ✅ 插入/删除快于 AVL
- ✅ 实际应用最广
- ✅ 最坏 O(log n)
- ❌ 实现复杂

**真实案例**:
- Go map（未使用，Go 用的是哈希表）
- Linux epoll 红黑树
- Java HashMap (JDK 8+ 链表转红黑树)

---

### 2.4 B-Tree / B+Tree

**原理**:
- **B-Tree**: m 阶树，每个节点最多 m 个子节点，节点内有序
- **B+Tree**: 非叶节点只存索引，叶节点存数据并通过链表连接

**参数**:
- 阶数 m: 通常根据磁盘页大小确定（如 4KB）
- 每个节点: ⌈m/2⌉ ~ m 个子节点

**复杂度**:
- 查找/插入/删除: O(log_m n)
- 树高: 极低（如 m=200, 10 亿数据树高仅 4）

**B+Tree 优势**:
- 范围查询高效（叶节点链表）
- 非叶节点更小 → 更多索引缓存在内存
- 磁盘 I/O 次数少

**应用场景**:
- 数据库索引（MySQL InnoDB, PostgreSQL）
- 文件系统（ext4, NTFS, Btrfs）
- 键值存储

**优缺点**:
- ✅ 磁盘 I/O 友好
- ✅ 范围查询高效
- ✅ 树高低
- ❌ 实现复杂
- ❌ 内存占用大

**真实案例**:
- MySQL InnoDB 主键索引
- MongoDB WiredTiger
- PostgreSQL B-Tree 索引

**设计要点**:
- 节点分裂/合并
- 顺序扫描优化
- 写时复制（COW）

---

### 2.5 字典树 (Trie / Prefix Tree)

**原理**: 树形结构，每个节点代表一个字符，从根到叶的路径构成字符串。

**复杂度**:
- 插入/查找: O(m) (m 为字符串长度)
- 空间: O(ALPHABET_SIZE × N × M)

**应用场景**:
- 自动补全
- 拼写检查
- IP 路由表（前缀匹配）
- 敏感词过滤

**优化技术**:
- **压缩 Trie (Radix Tree)**: 合并单分支节点
- **Double Array Trie**: 空间优化
- **Ternary Search Tree**: 折中方案

**优缺点**:
- ✅ 前缀查询 O(m)
- ✅ 字典序遍历
- ❌ 空间消耗大
- ❌ 缓存不友好

**真实案例**:
- Linux 内核路由表
- Redis 自动补全
- Nginx 路由匹配

**变种**:
- 后缀树（Suffix Tree）
- AC 自动机（多模式匹配）

---

### 2.6 线段树 (Segment Tree)

**原理**: 完全二叉树，每个节点表示一个区间，支持区间查询和修改。

**复杂度**:
- 构建: O(n)
- 区间查询/更新: O(log n)
- 空间: O(4n)

**应用场景**:
- 区间最值查询（RMQ）
- 区间和查询
- 懒惰传播（区间更新）
- 动态 DP

**优缺点**:
- ✅ 区间操作高效
- ✅ 支持在线查询
- ❌ 空间消耗大
- ❌ 实现复杂

**真实案例**:
- 竞赛编程常用
- 数据库范围查询优化
- 日志聚合系统

**变种**:
- 动态开点线段树（处理大区间）
- 主席树（可持久化线段树）
- zkw 线段树（非递归实现）

---

### 2.7 树状数组 (Fenwick Tree / Binary Indexed Tree)

**原理**: 利用二进制特性，通过数组实现高效的前缀和查询和单点更新。

**复杂度**:
- 构建: O(n log n) 或 O(n)
- 前缀和查询: O(log n)
- 单点更新: O(log n)
- 空间: O(n)

**核心操作**:
- lowbit(x) = x & (-x)
- 查询: 累加 tree[x], x -= lowbit(x)
- 更新: tree[x] += delta, x += lowbit(x)

**应用场景**:
- 动态前缀和
- 逆序对计数
- 区间更新（差分）

**优缺点**:
- ✅ 代码简洁
- ✅ 空间小
- ✅ 常数优于线段树
- ❌ 功能不如线段树全面

**对比线段树**:
- 树状数组: 代码短，常数小，前缀和专用
- 线段树: 功能强，任意区间查询

---

### 2.8 并查集 (Union-Find / Disjoint Set)

**原理**: 维护元素的集合分组，支持快速合并和查询是否在同一集合。

**优化技术**:
- **路径压缩**: find 时将路径上所有节点直接指向根
- **按秩合并**: 总是将矮树接到高树下

**复杂度**:
- 初始化: O(n)
- 查找/合并: O(α(n)) ≈ O(1) (α 为阿克曼函数的反函数)

**应用场景**:
- 最小生成树（Kruskal）
- 判断图的连通性
- 等价类划分
- 动态连通性问题

**优缺点**:
- ✅ 操作接近 O(1)
- ✅ 实现简单
- ✅ 空间 O(n)
- ❌ 不支持删除边

**真实案例**:
- 社交网络（朋友圈）
- 图像处理（连通域标记）
- 网络连通性检测

**进阶技巧**:
- 带权并查集
- 可持久化并查集
- 启发式合并

---

## 3. 哈希结构

### 3.1 哈希表 (Hash Table)

**原理**: 通过哈希函数将键映射到数组索引，实现 O(1) 查找。

**冲突解决**:
- **链地址法**: 冲突元素用链表连接（Java HashMap）
- **开放地址法**:
  - 线性探测
  - 二次探测
  - 双重哈希

**复杂度**:
- 查找/插入/删除: O(1) 平均, O(n) 最坏
- 空间: O(n)

**负载因子**:
- load_factor = n / capacity
- 通常 0.75 时扩容（Java HashMap）
- 扩容: rehash 到 2 倍大小

**应用场景**:
- 缓存实现
- 数据去重
- 统计频率
- 数据库索引（哈希索引）

**优缺点**:
- ✅ 平均 O(1) 操作
- ✅ 实现简单
- ❌ 最坏 O(n)
- ❌ 无序，不支持范围查询
- ❌ 哈希碰撞

**真实案例**:
- Redis Hash
- Go map
- Java HashMap
- Python dict

**设计要点**:
- 好的哈希函数（均匀分布）
- 合理的负载因子
- 高效的扩容策略
- 并发安全（分段锁、CAS）

**Java HashMap 优化**:
- JDK 8+: 链表长度 > 8 转红黑树
- 哈希扰动函数
- 尾插法（避免死循环）

---

### 3.2 布隆过滤器 (Bloom Filter)

**原理**: 位数组 + 多个哈希函数，快速判断元素**可能存在**或**一定不存在**。

**复杂度**:
- 插入/查询: O(k) (k 为哈希函数数量)
- 空间: m bits

**参数设计**:
- m: 位数组大小
- n: 预期元素数量
- k: 哈希函数数量
- p: 误判率

**公式**:
- m = -n ln(p) / (ln 2)²
- k = (m/n) ln 2

**应用场景**:
- 缓存穿透防护
- 爬虫 URL 去重
- 数据库查询优化（LSM-Tree）
- 垃圾邮件过滤

**误判特性**:
- ✅ 不会漏报 (false negative = 0)
- ❌ 可能误报 (false positive > 0)
- ❌ 不支持删除（可用 Counting Bloom Filter）

**优缺点**:
- ✅ 空间极省
- ✅ 查询极快
- ❌ 有误判率
- ❌ 不支持删除

**真实案例**:
- Google BigTable
- Cassandra SSTable 过滤
- Chrome 安全浏览
- Bitcoin SPV 钱包

**变种**:
- Counting Bloom Filter（支持删除）
- Cuckoo Filter（更低误判率 + 支持删除）

---

### 3.3 Count-Min Sketch

**原理**: 多个哈希函数 + 计数矩阵，估计元素频率，允许误差。

**复杂度**:
- 更新/查询: O(k)
- 空间: O(k × w)

**参数**:
- k: 哈希函数数量
- w: 每行宽度
- ε: 误差范围
- δ: 置信度

**应用场景**:
- 流量统计（Top-K 热点）
- 网络流量分析
- 数据库查询优化

**优缺点**:
- ✅ 空间小
- ✅ 适合大数据流
- ❌ 只能高估，不能低估
- ❌ 有误差

**真实案例**:
- Redis HyperLogLog（基于类似原理）
- 网络流量监控

---

### 3.4 HyperLogLog

**原理**: 基于概率统计的基数估计算法，极小空间估计集合基数。

**复杂度**:
- 添加/估计: O(1)
- 空间: 约 12KB（标准误差 0.81%）

**应用场景**:
- UV（独立访客）统计
- 去重计数
- 大数据集基数估计

**优缺点**:
- ✅ 空间极小（12KB 可统计 2^64 基数）
- ✅ 误差可控（~0.81%）
- ❌ 只能计数，无法获取元素
- ❌ 有误差

**真实案例**:
- Redis PFCOUNT
- Google Analytics
- Presto 去重统计

---

## 4. 堆结构

### 4.1 二叉堆 (Binary Heap)

**原理**: 完全二叉树，满足堆性质（最大堆：父节点 ≥ 子节点）。

**复杂度**:
- 插入: O(log n)
- 删除最值: O(log n)
- 查看最值: O(1)
- 建堆: O(n)

**实现方式**:
- 数组表示：i 的左子 = 2i+1，右子 = 2i+2，父 = (i-1)/2

**应用场景**:
- 优先队列
- 堆排序
- Top-K 问题
- 任务调度

**优缺点**:
- ✅ 简单高效
- ✅ 数组实现，缓存友好
- ❌ 不支持高效合并
- ❌ 不支持随机访问

**真实案例**:
- Go heap 包
- Python heapq
- Java PriorityQueue
- Linux 定时器

**操作**:
- 上浮 (bubble up)
- 下沉 (bubble down)
- 堆化 (heapify)

---

### 4.2 斐波那契堆 (Fibonacci Heap)

**原理**: 多棵树的集合，延迟合并，摊还性能优异。

**复杂度（摊还）**:
- 插入: O(1)
- 合并: O(1)
- 删除最小值: O(log n)
- 减小键: O(1)

**应用场景**:
- Dijkstra 算法优化
- Prim 算法优化
- 理论研究

**优缺点**:
- ✅ 摊还性能优异
- ✅ 合并 O(1)
- ❌ 实现复杂
- ❌ 常数大
- ❌ 实际应用少

**真实案例**:
- 理论优化 Dijkstra
- 学术研究

---

### 4.3 左偏树 (Leftist Heap)

**原理**: 二叉树，左子树的距离 ≥ 右子树，支持高效合并。

**复杂度**:
- 合并: O(log n)
- 插入: O(log n)
- 删除最小值: O(log n)

**应用场景**:
- 需要频繁合并的优先队列
- 竞赛编程

**优缺点**:
- ✅ 支持高效合并
- ✅ 实现相对简单
- ❌ 不如二叉堆常见

---

## 5. 图结构

### 5.1 邻接矩阵 (Adjacency Matrix)

**原理**: 二维数组 matrix[i][j] 表示节点 i 到节点 j 的边。

**复杂度**:
- 空间: O(V²)
- 检查边存在: O(1)
- 遍历邻居: O(V)
- 添加/删除边: O(1)

**应用场景**:
- 稠密图
- 需要快速查边
- Floyd-Warshall 算法

**优缺点**:
- ✅ 查边 O(1)
- ✅ 实现简单
- ❌ 空间浪费（稀疏图）
- ❌ 遍历邻居慢

---

### 5.2 邻接表 (Adjacency List)

**原理**: 每个节点维护一个邻居列表（数组/链表）。

**复杂度**:
- 空间: O(V + E)
- 检查边存在: O(degree)
- 遍历邻居: O(degree)
- 添加边: O(1)

**应用场景**:
- 稀疏图
- 大多数图算法（BFS, DFS, Dijkstra）

**优缺点**:
- ✅ 空间高效（稀疏图）
- ✅ 遍历邻居快
- ❌ 查边慢

**真实案例**:
- 社交网络图
- 网页链接图
- 路由图

---

## 6. 高级数据结构

### 6.1 跳表 (Skip List)

**原理**: 多层有序链表，每层是下层的抽样，实现 O(log n) 查找。

**复杂度**:
- 查找/插入/删除: O(log n) 期望
- 空间: O(n)

**层数决定**:
- 抛硬币决定层数
- 期望层数: log n

**应用场景**:
- Redis Sorted Set
- 替代平衡树
- 并发数据结构

**优缺点**:
- ✅ 实现简单（比红黑树）
- ✅ 并发性能好
- ✅ 范围查询高效
- ❌ 空间消耗较大
- ❌ 查询性能略逊于红黑树

**真实案例**:
- Redis ZSET
- LevelDB MemTable
- ConcurrentSkipListMap (Java)

**并发优势**:
- 无需全局锁
- 乐观并发控制
- CAS 操作

---

### 6.2 LSM-Tree (Log-Structured Merge-Tree)

**原理**:
- 写入先进内存 MemTable（跳表）
- 满了刷盘为 SSTable（不可变）
- 后台定期合并（Compaction）

**复杂度**:
- 写入: O(1) 内存
- 读取: O(log n × L) (L 为层数)
- 空间: 放大因子 2-10

**组件**:
- **MemTable**: 内存中的跳表
- **SSTable**: 磁盘上的有序表
- **Bloom Filter**: 加速查找
- **WAL**: 写前日志，保证持久性

**Compaction 策略**:
- **Leveled**: 层级合并（RocksDB 默认）
- **Tiered**: 大小触发合并
- **FIFO**: 时间窗口淘汰

**应用场景**:
- 写多读少
- 时序数据
- 日志存储
- NoSQL 数据库

**优缺点**:
- ✅ 写入性能极高
- ✅ 顺序 I/O
- ✅ 压缩率高
- ❌ 读放大
- ❌ 写放大（Compaction）
- ❌ 空间放大

**真实案例**:
- RocksDB (Meta, LinkedIn)
- LevelDB (Google)
- Cassandra
- HBase
- ScyllaDB

**优化技巧**:
- Partitioned Index
- Block Cache
- Column Family

---

### 6.3 倒排索引 (Inverted Index)

**原理**: 词 → 文档列表的映射，搜索引擎核心数据结构。

**结构**:
- **词典**: 所有词的集合（Trie/Hash）
- **倒排列表**: 每个词对应的文档 ID 列表
- **位置信息**: 词在文档中的位置（可选）

**复杂度**:
- 构建: O(N) (N 为总词数)
- 查询: O(k) (k 为结果文档数)

**应用场景**:
- 搜索引擎（Elasticsearch）
- 全文检索
- 日志搜索

**优化技术**:
- 跳表压缩
- Frame of Reference 编码
- 倒排列表合并优化

**真实案例**:
- Elasticsearch / Lucene
- Solr
- Google 搜索

---

### 6.4 位图 (Bitmap)

**原理**: 用 bit 表示数据，1 个 bit 表示 1 个元素存在性。

**复杂度**:
- 设置/查询: O(1)
- 空间: n/8 字节

**应用场景**:
- 大规模去重（如 40 亿个整数）
- 用户标签系统
- 权限管理
- 布隆过滤器基础

**优缺点**:
- ✅ 空间极省
- ✅ 操作极快
- ✅ 支持位运算（AND, OR, XOR）
- ❌ 稀疏数据浪费空间

**真实案例**:
- Redis Bitmap
- Linux 文件系统 inode 位图
- 数据库查询优化

---

### 6.5 Roaring Bitmap

**原理**: 分段压缩位图，稀疏段用数组，稠密段用位图。

**复杂度**:
- 操作: O(1) ~ O(log n)
- 空间: 远小于普通 Bitmap（稀疏数据）

**应用场景**:
- 大规模稀疏数据去重
- OLAP 查询优化
- 用户画像

**优缺点**:
- ✅ 稀疏数据高效
- ✅ 压缩率高
- ✅ 操作快
- ❌ 实现复杂

**真实案例**:
- Apache Spark
- Apache Druid
- Lucene 8.0+

---

# 第二部分：算法

## 7. 排序算法

### 7.1 快速排序 (QuickSort)

**原理**: 分治法，选择 pivot 将数组分为两部分递归排序。

**复杂度**:
- 平均: O(n log n)
- 最坏: O(n²) (已排序数组)
- 空间: O(log n) 递归栈
- **不稳定**

**优化技巧**:
- **三数取中**: 取首/中/尾三者中位数作为 pivot
- **小数组切换插入排序**: n < 10 时用插入排序
- **三路快排**: 处理大量重复元素
- **尾递归优化**: 减少栈深度

**应用场景**:
- 通用排序
- 数据库排序
- Top-K 问题（快速选择）

**真实案例**:
- Linux qsort()
- Java Arrays.sort() (DualPivotQuicksort)
- Go sort.Sort()

**代码框架**:
```go
func quickSort(arr []int, left, right int) {
    if left >= right { return }
    pivot := partition(arr, left, right)
    quickSort(arr, left, pivot-1)
    quickSort(arr, pivot+1, right)
}
```

---

### 7.2 归并排序 (MergeSort)

**原理**: 分治法，将数组分为两半分别排序后合并。

**复杂度**:
- 时间: O(n log n) 所有情况
- 空间: O(n)
- **稳定**

**应用场景**:
- 外部排序（大文件）
- 链表排序（空间 O(1)）
- 需要稳定排序的场景
- 求逆序对

**优缺点**:
- ✅ 稳定排序
- ✅ 最坏情况性能好
- ✅ 适合链表
- ❌ 需要额外空间

**真实案例**:
- Git 分支合并
- Hadoop 外部排序
- Python sort() (Timsort 基于归并)

---

### 7.3 堆排序 (HeapSort)

**原理**: 构建最大堆，依次取出堆顶元素。

**复杂度**:
- 时间: O(n log n)
- 空间: O(1)
- **不稳定**

**步骤**:
1. 建堆: O(n)
2. 交换堆顶与末尾，调整堆: n 次 O(log n)

**应用场景**:
- 空间受限场景
- Top-K 问题
- 优先队列

**优缺点**:
- ✅ 空间 O(1)
- ✅ 最坏情况 O(n log n)
- ❌ 不稳定
- ❌ 缓存不友好

**真实案例**:
- Linux CFS 调度器
- 操作系统内存管理

---

### 7.4 计数排序 (Counting Sort)

**原理**: 统计每个值出现次数，按次数输出。

**复杂度**:
- 时间: O(n + k) (k 为值域范围)
- 空间: O(k)
- **稳定**

**限制**:
- 只能用于整数
- 值域范围不能太大

**应用场景**:
- 小范围整数排序
- 作为基数排序的子过程
- 年龄排序

**优缺点**:
- ✅ 线性时间
- ✅ 稳定
- ❌ 空间消耗大（值域大时）
- ❌ 只能整数

---

### 7.5 基数排序 (Radix Sort)

**原理**: 按位排序，从低位到高位依次用计数排序。

**复杂度**:
- 时间: O(d × (n + k)) (d 为位数，k 为基数)
- 空间: O(n + k)
- **稳定**

**应用场景**:
- 大整数排序
- 字符串排序
- IP 地址排序

**优缺点**:
- ✅ 线性时间（位数固定时）
- ✅ 稳定
- ❌ 空间消耗
- ❌ 只能整数/字符串

---

### 7.6 桶排序 (Bucket Sort)

**原理**: 将数据分到多个桶，每个桶内排序，最后合并。

**复杂度**:
- 平均: O(n + k)
- 最坏: O(n²)
- 空间: O(n + k)

**应用场景**:
- 均匀分布的数据
- 外部排序
- MapReduce 排序

**优缺点**:
- ✅ 平均线性时间
- ✅ 可并行化
- ❌ 依赖数据分布
- ❌ 空间消耗

---

### 7.7 TimSort

**原理**: 归并排序 + 插入排序的混合，利用数据中的有序性。

**复杂度**:
- 平均/最坏: O(n log n)
- 最好: O(n) (已排序)
- **稳定**

**特点**:
- 检测数据中的升序/降序片段（run）
- 小片段用插入排序
- 大片段用归并排序
- 优化了实际数据的表现

**真实案例**:
- Python sort()
- Java Arrays.sort() (对象)
- Android 系统排序

---

### 排序算法对比表

| 算法 | 平均 | 最坏 | 空间 | 稳定性 | 场景 |
|------|------|------|------|--------|------|
| 快速排序 | O(n log n) | O(n²) | O(log n) | ❌ | 通用 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | ✅ | 稳定排序、外部排序 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | ❌ | 空间受限 |
| 插入排序 | O(n²) | O(n²) | O(1) | ✅ | 小数组、近乎有序 |
| 计数排序 | O(n+k) | O(n+k) | O(k) | ✅ | 小范围整数 |
| 基数排序 | O(d(n+k)) | O(d(n+k)) | O(n+k) | ✅ | 固定位数整数 |
| TimSort | O(n log n) | O(n log n) | O(n) | ✅ | 实际数据 |

---

## 8. 搜索算法

### 8.1 二分查找 (Binary Search)

**原理**: 在有序数组中，每次比较中间元素，缩小一半范围。

**复杂度**:
- 时间: O(log n)
- 空间: O(1)

**变种**:
- **查找第一个等于目标值**: `lower_bound`
- **查找最后一个等于目标值**: `upper_bound`
- **查找第一个大于等于**: `>=`
- **查找最后一个小于等于**: `<=`
- **旋转数组查找**
- **峰值查找**

**应用场景**:
- 有序数据查找
- 搜索空间二分
- 答案二分（最大化最小值问题）

**模板代码**:
```go
// 查找第一个 >= target 的位置
func lowerBound(arr []int, target int) int {
    left, right := 0, len(arr)
    for left < right {
        mid := left + (right - left) / 2
        if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}
```

**真实案例**:
- MySQL InnoDB B+Tree 页内查找
- Redis ZSET 排名查询
- C++ lower_bound / upper_bound

---

### 8.2 插值查找 (Interpolation Search)

**原理**: 根据值的分布估计位置，类似字典查单词。

**复杂度**:
- 平均: O(log log n)
- 最坏: O(n)

**应用场景**:
- 均匀分布的有序数据

**优缺点**:
- ✅ 均匀分布时更快
- ❌ 分布不均时退化

---

### 8.3 斐波那契查找

**原理**: 类似二分，但用斐波那契数列分割。

**复杂度**:
- 时间: O(log n)

**优点**:
- 只用加减法（古老 CPU 无乘除法时有优势）

**现代应用**: 少

---

## 9. 字符串算法

### 9.1 KMP (Knuth-Morris-Pratt)

**原理**: 利用部分匹配信息，构建 next 数组避免回溯。

**复杂度**:
- 预处理: O(m)
- 匹配: O(n)
- 空间: O(m)

**next 数组含义**: next[i] = 模式串 [0..i] 的最长相同前后缀长度

**应用场景**:
- 字符串匹配
- 文本搜索
- DNA 序列匹配

**优缺点**:
- ✅ 线性时间
- ✅ 无回溯
- ❌ 实现复杂
- ❌ 实际常数大

**真实案例**:
- Linux strstr() 部分实现
- 文本编辑器查找

---

### 9.2 Boyer-Moore

**原理**: 从模式串尾部开始匹配，利用坏字符和好后缀规则跳过更多字符。

**复杂度**:
- 预处理: O(m + σ) (σ 为字符集大小)
- 匹配: O(n/m) 平均, O(nm) 最坏

**规则**:
- **坏字符规则**: 不匹配时，根据坏字符在模式串中的位置跳过
- **好后缀规则**: 已匹配的后缀，查找模式串中其他出现位置

**应用场景**:
- 文本编辑器查找（实际最快）
- 病毒扫描

**优缺点**:
- ✅ 实际最快（比 KMP）
- ✅ 平均子线性时间
- ❌ 实现复杂

**真实案例**:
- GNU grep
- 大多数文本编辑器

---

### 9.3 Rabin-Karp

**原理**: 滚动哈希，将字符串哈希为整数比较。

**复杂度**:
- 平均: O(n + m)
- 最坏: O(nm)

**滚动哈希**:
```
hash = (hash - arr[left] * base) * base + arr[right]
```

**应用场景**:
- 多模式匹配
- 抄袭检测
- 字符串去重

**优缺点**:
- ✅ 支持多模式
- ✅ 实现简单
- ❌ 哈希碰撞

**真实案例**:
- Google 代码抄袭检测
- Turnitin 查重

---

### 9.4 AC 自动机 (Aho-Corasick)

**原理**: Trie + KMP，构建失败指针实现多模式匹配。

**复杂度**:
- 构建: O(Σm)
- 匹配: O(n + z) (z 为匹配次数)

**应用场景**:
- 敏感词过滤
- 网络入侵检测（多病毒特征匹配）
- 生物信息学

**优缺点**:
- ✅ 一次扫描匹配多个模式
- ✅ 线性时间
- ❌ 空间消耗大

**真实案例**:
- Snort IDS
- ClamAV 病毒扫描
- 内容审核系统

---

### 9.5 Manacher 算法

**原理**: O(n) 求最长回文子串，利用回文的对称性避免重复计算。

**复杂度**:
- 时间: O(n)
- 空间: O(n)

**技巧**:
- 插入分隔符统一奇偶长度
- 维护最右回文边界

**应用场景**:
- 最长回文子串
- 竞赛编程

---

### 9.6 后缀数组 (Suffix Array)

**原理**: 所有后缀按字典序排序后的索引数组。

**复杂度**:
- 构建: O(n log n) (倍增算法)
- 查询: O(m log n) (二分)

**应用场景**:
- 最长公共子串
- 字符串重复子串
- 全文索引

**优缺点**:
- ✅ 空间比后缀树小
- ✅ 功能强大
- ❌ 构建复杂

---

### 9.7 Z 算法

**原理**: 计算字符串 s 与其每个后缀的最长公共前缀。

**复杂度**:
- 时间: O(n)
- 空间: O(n)

**应用场景**:
- 字符串匹配（类似 KMP）
- 模式匹配

**优点**:
- 实现比 KMP 简单
- 线性时间

---

## 10. 图算法

### 10.1 深度优先搜索 (DFS)

**原理**: 递归或栈实现，沿着一条路径走到底再回溯。

**复杂度**:
- 时间: O(V + E)
- 空间: O(V)

**应用场景**:
- 连通性检测
- 拓扑排序
- 环检测
- 路径搜索
- 回溯问题

**实现方式**:
- 递归
- 显式栈

**真实案例**:
- 文件系统遍历
- 迷宫求解

---

### 10.2 广度优先搜索 (BFS)

**原理**: 队列实现，逐层遍历。

**复杂度**:
- 时间: O(V + E)
- 空间: O(V)

**应用场景**:
- 最短路径（无权图）
- 层序遍历
- 最小步数问题

**真实案例**:
- 社交网络好友推荐
- 网络爬虫
- 迷宫最短路径

---

### 10.3 Dijkstra 最短路径

**原理**: 贪心算法，使用优先队列逐步扩展最短路径。

**复杂度**:
- 时间: O((V + E) log V) (优先队列)
- 空间: O(V)

**限制**:
- 不支持负权边

**应用场景**:
- 地图导航
- 网络路由 (OSPF)
- 游戏 AI

**优化**:
- Fibonacci Heap: O(E + V log V)
- Bidirectional Dijkstra

**真实案例**:
- Google Maps
- 路由协议 OSPF

---

### 10.4 Bellman-Ford 最短路径

**原理**: 动态规划，松弛 V-1 轮所有边。

**复杂度**:
- 时间: O(VE)
- 空间: O(V)

**优势**:
- 支持负权边
- 能检测负环

**应用场景**:
- 网络路由（Distance Vector）
- 金融套利检测

**真实案例**:
- RIP 路由协议
- 货币汇率套利

---

### 10.5 Floyd-Warshall 全源最短路径

**原理**: 动态规划，枚举中间节点。

**复杂度**:
- 时间: O(V³)
- 空间: O(V²)

**应用场景**:
- 稠密图全源最短路径
- 传递闭包

**优点**:
- 实现简单
- 求所有点对最短路径

**真实案例**:
- 网络可达性分析

---

### 10.6 A* 寻路算法

**原理**: Dijkstra + 启发式函数 h(n)。

**评估函数**: f(n) = g(n) + h(n)
- g(n): 起点到 n 的实际距离
- h(n): n 到终点的估计距离

**复杂度**:
- 取决于启发函数质量

**启发函数要求**:
- **可采纳性**: h(n) ≤ 真实距离
- **一致性**: h(n) ≤ cost(n, n') + h(n')

**应用场景**:
- 游戏 AI 寻路
- 机器人路径规划
- 地图导航优化

**常用启发函数**:
- 曼哈顿距离（网格图）
- 欧几里得距离
- 切比雪夫距离

**真实案例**:
- StarCraft AI
- 自动驾驶路径规划
- Google Maps

---

### 10.7 SPFA (Shortest Path Faster Algorithm)

**原理**: Bellman-Ford 的队列优化。

**复杂度**:
- 平均: O(kE) (k 为常数 < 2)
- 最坏: O(VE)

**优化**:
- SLF 优化
- LLL 优化

**应用场景**:
- 稀疏图负权边最短路径
- 竞赛编程

**注意**:
- 可能被卡到 O(VE)

---

### 10.8 拓扑排序

**原理**: 对 DAG 进行线性排序，使所有边从前指向后。

**复杂度**:
- 时间: O(V + E)
- 空间: O(V)

**实现方式**:
- **Kahn 算法**: BFS + 入度
- **DFS**: 后序遍历倒序

**应用场景**:
- 任务调度
- 编译依赖
- 课程安排

**真实案例**:
- Makefile 构建顺序
- Maven 依赖解析
- npm 包安装顺序

---

### 10.9 最小生成树 - Prim

**原理**: 从单点开始，每次选择最小边扩展到新节点。

**复杂度**:
- 时间: O(E log V) (优先队列)
- 空间: O(V)

**应用场景**:
- 稠密图
- 网络设计

**真实案例**:
- 电网布局
- 通信网络设计

---

### 10.10 最小生成树 - Kruskal

**原理**: 按边权排序，使用并查集避免环。

**复杂度**:
- 时间: O(E log E)
- 空间: O(V)

**应用场景**:
- 稀疏图
- 集群分析

**真实案例**:
- 图像分割
- 城市道路规划

---

### 10.11 强连通分量 - Tarjan

**原理**: DFS + 栈，一次遍历求强连通分量。

**复杂度**:
- 时间: O(V + E)
- 空间: O(V)

**应用场景**:
- 有向图强连通分量
- 死锁检测

**真实案例**:
- 编译器优化
- 社交网络分析

---

### 10.12 二分图匹配 - 匈牙利算法

**原理**: 增广路径算法。

**复杂度**:
- 时间: O(VE)

**应用场景**:
- 任务分配
- 婚配问题

---

### 10.13 网络流 - Ford-Fulkerson

**原理**: 不断寻找增广路径直到无法增广。

**复杂度**:
- 时间: O(E × max_flow)

**应用场景**:
- 最大流问题
- 最小割

---

### 10.14 网络流 - Dinic

**原理**: 分层图 + DFS 多路增广。

**复杂度**:
- 时间: O(V² E)

**应用场景**:
- 最大流
- 二分图最大匹配

---

## 11. 动态规划

### 11.1 背包问题

#### 0-1 背包

**问题**: n 个物品，每个物品重量 w[i]，价值 v[i]，背包容量 W，求最大价值。

**状态定义**: dp[i][j] = 前 i 个物品，容量 j 的最大价值

**转移方程**:
```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
```

**复杂度**:
- 时间: O(nW)
- 空间: O(W) (滚动数组优化)

**应用场景**:
- 资源分配
- 项目选择

---

#### 完全背包

**问题**: 每个物品可选无限次。

**转移方程**:
```
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
```

**区别**: 第二项取 dp[i] 而非 dp[i-1]

---

#### 多重背包

**问题**: 每个物品有数量限制 k[i]。

**优化**: 二进制优化转化为 0-1 背包

---

### 11.2 最长公共子序列 (LCS)

**问题**: 两个序列的最长公共子序列。

**状态定义**: dp[i][j] = s1[0..i] 和 s2[0..j] 的 LCS 长度

**转移方程**:
```
if s1[i] == s2[j]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

**复杂度**: O(mn)

**应用场景**:
- Git diff
- 文本相似度
- DNA 序列比对

---

### 11.3 最长递增子序列 (LIS)

**问题**: 序列中最长严格递增子序列。

**方法 1**: DP O(n²)
```
dp[i] = max(dp[j] + 1) where j < i and arr[j] < arr[i]
```

**方法 2**: 贪心 + 二分 O(n log n)
- 维护一个 tails 数组，tails[i] 表示长度为 i+1 的 LIS 的最小尾部元素

**应用场景**:
- 俄罗斯方块
- 耐心排序

---

### 11.4 编辑距离

**问题**: 将字符串 s1 转换为 s2 的最少操作数（插入/删除/替换）。

**状态定义**: dp[i][j] = s1[0..i] 转 s2[0..j] 的最少操作

**转移方程**:
```
if s1[i] == s2[j]:
    dp[i][j] = dp[i-1][j-1]
else:
    dp[i][j] = 1 + min(
        dp[i-1][j],      // 删除
        dp[i][j-1],      // 插入
        dp[i-1][j-1]     // 替换
    )
```

**复杂度**: O(mn)

**应用场景**:
- 拼写纠错
- DNA 序列比对
- Git merge

---

### 11.5 区间 DP

**经典问题**: 矩阵链乘法、石子合并

**特点**: 按区间长度递推

**状态定义**: dp[i][j] = 区间 [i, j] 的最优解

**遍历顺序**:
```go
for length := 2; length <= n; length++ {
    for i := 0; i <= n - length; i++ {
        j := i + length - 1
        // 计算 dp[i][j]
    }
}
```

---

### 11.6 状态压缩 DP

**原理**: 用整数的二进制位表示状态。

**经典问题**:
- 旅行商问题 (TSP)
- 集合覆盖
- 棋盘问题

**复杂度**: O(2^n × ...)

**应用场景**:
- n ≤ 20 的子集枚举问题

---

### 11.7 树形 DP

**经典问题**:
- 树的直径
- 树上背包
- 最大独立集

**特点**: 在树上进行 DP，通常用 DFS 后序遍历

---

## 12. 贪心算法

### 12.1 活动选择问题

**问题**: 选择最多的不相交活动。

**贪心策略**: 每次选择最早结束的活动。

**复杂度**: O(n log n)

**正确性证明**: 交换论证

---

### 12.2 霍夫曼编码

见 [17.1 Huffman Coding](#171-huffman-coding)

---

### 12.3 分数背包

**问题**: 可以取物品的分数部分。

**贪心策略**: 按单位重量价值排序，贪心选择。

**复杂度**: O(n log n)

---

### 12.4 Dijkstra 算法

见 [10.3 Dijkstra](#103-dijkstra-最短路径)

---

## 13. 分治算法

### 13.1 归并排序

见 [7.2 归并排序](#72-归并排序-mergesort)

---

### 13.2 快速排序

见 [7.1 快速排序](#71-快速排序-quicksort)

---

### 13.3 二分查找

见 [8.1 二分查找](#81-二分查找-binary-search)

---

### 13.4 大整数乘法 - Karatsuba

**原理**: 分治法，将大整数拆分递归计算。

**复杂度**: O(n^1.58)

**对比**: 朴素 O(n²)

---

### 13.5 快速傅里叶变换 (FFT)

**原理**: 分治法计算多项式乘法。

**复杂度**: O(n log n)

**应用场景**:
- 信号处理
- 大整数乘法
- 图像处理

---

## 14. 回溯算法

### 14.1 N 皇后

**问题**: n×n 棋盘放置 n 个皇后，使其互不攻击。

**复杂度**: O(n!)

**优化**: 剪枝

---

### 14.2 数独求解

**方法**: 回溯 + 剪枝

---

### 14.3 全排列/组合

**全排列**: O(n!)
**组合**: O(2^n)

---

## 15. 数学算法

### 15.1 质数判定

#### 试除法

**复杂度**: O(√n)

---

#### Miller-Rabin

**原理**: 概率算法，基于费马小定理。

**复杂度**: O(k log³ n) (k 为测试次数)

**应用**: 大素数判定

---

### 15.2 最大公约数 - 欧几里得算法

**原理**: gcd(a, b) = gcd(b, a % b)

**复杂度**: O(log min(a, b))

**扩展欧几里得**: 求解 ax + by = gcd(a, b)

---

### 15.3 快速幂

**原理**: a^n 拆分为二进制位。

**复杂度**: O(log n)

**代码**:
```go
func pow(a, n int) int {
    res := 1
    for n > 0 {
        if n & 1 == 1 {
            res *= a
        }
        a *= a
        n >>= 1
    }
    return res
}
```

---

### 15.4 矩阵快速幂

**应用**:
- 斐波那契数列 O(log n)
- 图的路径计数

---

### 15.5 线性筛 (欧拉筛)

**原理**: O(n) 筛选质数，每个合数只被最小质因子筛一次。

**复杂度**: O(n)

**对比埃氏筛**: O(n log log n)

---

### 15.6 中国剩余定理 (CRT)

**问题**: 求解同余方程组。

**应用**: RSA 加密优化

---

## 16. 位运算技巧

### 16.1 基本位运算

- 判断奇偶: `n & 1`
- 除以 2: `n >> 1`
- 乘以 2: `n << 1`
- 交换变量: `a ^= b; b ^= a; a ^= b`
- 取反: `~n`
- 设置第 k 位: `n | (1 << k)`
- 清除第 k 位: `n & ~(1 << k)`
- 检查第 k 位: `(n >> k) & 1`
- 清除最低位的 1: `n & (n - 1)`

---

### 16.2 Brian Kernighan 算法

**应用**: 统计 1 的个数

**原理**: n & (n-1) 清除最低位的 1

**复杂度**: O(1 的个数)

---

### 16.3 位掩码 DP

**应用**: 状态压缩 DP（见 11.6）

---

## 17. 压缩算法

### 17.1 Huffman Coding

**原理**: 基于字符频率构建最优前缀编码树。

**复杂度**:
- 构建: O(n log n)
- 编码/解码: O(n)

**应用场景**:
- ZIP 文件
- JPEG 图像
- MP3 音频

**真实案例**:
- gzip (Huffman + LZ77)

---

### 17.2 LZ77/LZ78

**原理**: 字典压缩，重复字符串替换为引用。

**复杂度**: O(n)

**应用场景**:
- gzip
- PNG 图像
- HTTP 压缩

**真实案例**:
- Nginx gzip
- Git 对象存储

---

### 17.3 Snappy

**原理**: Google 开发，速度优先。

**性能**:
- 压缩: ~250 MB/s
- 解压: ~500 MB/s
- 压缩率: 1.5-1.7x

**应用场景**:
- Kafka 消息压缩
- RocksDB 数据块
- BigTable

**真实案例**:
- Hadoop
- Cassandra

---

### 17.4 Zstandard (zstd)

**原理**: LZ77 + Huffman + FSE。

**性能**:
- 压缩: ~400 MB/s
- 解压: ~1200 MB/s
- 压缩率: 优于 gzip

**应用场景**:
- Linux 内核压缩
- MySQL 数据压缩
- Docker 镜像

**真实案例**:
- Meta 生产环境
- Facebook

---

### 17.5 Brotli

**原理**: Google 开发，HTTP 压缩专用。

**性能**:
- 压缩率: 优于 gzip 20%
- 速度: 略慢于 gzip

**应用场景**:
- HTTP 响应压缩
- 静态资源压缩

**真实案例**:
- Chrome
- CDN

---

## 18. 哈希算法

### 18.1 一致性哈希

**原理**: 哈希环 + 虚拟节点。

**复杂度**:
- 查找: O(log n)
- 添加/删除节点: O(k log n)

**应用场景**:
- 分布式缓存
- 分布式存储
- CDN

**真实案例**:
- Redis Cluster
- Memcached
- Cassandra
- Amazon Dynamo

**虚拟节点**: 100-200 个/物理节点

---

### 18.2 MurmurHash

**原理**: 非加密哈希，位运算 + 乘法。

**性能**: ~2-3 GB/s

**应用场景**:
- HashMap 内部哈希
- 布隆过滤器
- 数据去重

**真实案例**:
- Redis 字典
- Guava BloomFilter

---

### 18.3 xxHash

**原理**: 极速哈希，SIMD 优化。

**性能**: ~10 GB/s

**应用场景**:
- 高性能去重
- Checksum

**真实案例**:
- Zstandard
- LZ4

---

### 18.4 SHA-256

**原理**: 安全哈希，Merkle-Damgård 结构。

**输出**: 256 bits

**应用场景**:
- 区块链
- 数字签名
- 文件校验

**真实案例**:
- Bitcoin
- Git commit hash
- TLS/SSL

---

### 18.5 CityHash

**原理**: Google 开发，优化短字符串。

**应用场景**:
- 短字符串哈希
- C++ 内部实现

---

## 19. 加密算法

### 19.1 AES

**原理**: 对称加密，SPN 网络。

**密钥长度**: 128/192/256 bits

**性能**: ~1-5 GB/s (AES-NI)

**应用场景**:
- HTTPS
- 数据库加密
- 磁盘加密

**真实案例**:
- TLS 1.3
- FileVault

---

### 19.2 RSA

**原理**: 非对称加密，大数分解。

**密钥长度**: 2048/4096 bits

**应用场景**:
- 数字签名
- SSL/TLS 握手
- SSH 认证

**真实案例**:
- HTTPS 证书
- JWT 签名

---

### 19.3 ECC (椭圆曲线加密)

**原理**: 椭圆曲线离散对数。

**优势**: 256-bit ECC ≈ 3072-bit RSA

**应用场景**:
- 移动设备
- 区块链
- TLS 1.3

**真实案例**:
- Bitcoin
- Ethereum
- Apple iMessage

---

### 19.4 ChaCha20

**原理**: 流加密，速度快。

**应用场景**:
- TLS 1.3 (无 AES-NI 时)
- VPN

---

## 20. 缓存淘汰算法

### 20.1 LRU (Least Recently Used)

**原理**: HashMap + 双链表。

**复杂度**: O(1)

**应用场景**:
- Redis 淘汰
- 操作系统页面置换
- 浏览器缓存

**真实案例**:
- MySQL InnoDB Buffer Pool
- Nginx 缓存

---

### 20.2 LFU (Least Frequently Used)

**原理**: 双 HashMap。

**复杂度**: O(1)

**应用场景**:
- 热点数据识别
- CDN 缓存

**真实案例**:
- Redis LFU 模式
- Caffeine Cache

---

### 20.3 ARC (Adaptive Replacement Cache)

**原理**: LRU + LFU 自适应。

**应用场景**:
- PostgreSQL 缓存
- ZFS 文件系统

---

### 20.4 FIFO

**原理**: 先进先出。

**复杂度**: O(1)

**应用场景**:
- 简单缓存
- 队列

---

### 20.5 CLOCK (时钟算法)

**原理**: 环形链表 + 访问位。

**应用场景**:
- 操作系统页面置换

---

### 20.6 2Q

**原理**: 两个队列，FIFO + LRU。

**应用场景**:
- 缓存扫描抵抗

---

## 21. 分布式系统算法

### 21.1 Raft

**原理**: Leader 选举 + 日志复制。

**核心**:
- Leader Election
- Log Replication
- Safety

**复杂度**:
- 消息: O(n)
- 选举时间: ~150-300ms

**应用场景**:
- 分布式配置中心
- 分布式数据库
- 服务注册中心

**真实案例**:
- etcd (Kubernetes)
- Consul
- TiDB
- CockroachDB

---

### 21.2 Paxos

**原理**: 两阶段提交变体。

**阶段**:
- Phase 1: Prepare
- Phase 2: Accept

**应用场景**:
- Google Chubby
- Apache ZooKeeper (Zab)

**真实案例**:
- Google Spanner
- ZooKeeper

---

### 21.3 Gossip 协议

**原理**: 节点随机交换信息，指数传播。

**复杂度**:
- 传播延迟: O(log n)
- 消息数: O(n log n)

**应用场景**:
- 集群成员发现
- 故障检测
- 数据同步

**真实案例**:
- Cassandra
- Redis Cluster
- Consul

---

### 21.4 Vector Clock

**原理**: 逻辑时钟向量，检测因果关系。

**复杂度**:
- 空间: O(n)
- 比较: O(n)

**应用场景**:
- Dynamo 冲突检测
- 分布式版本控制
- 因果一致性

**真实案例**:
- Amazon Dynamo
- Riak
- Voldemort

---

### 21.5 CRDT (Conflict-free Replicated Data Types)

**原理**: 数学保证最终一致性的数据类型。

**类型**:
- G-Counter (增长计数器)
- PN-Counter (正负计数器)
- LWW-Element-Set (最后写入胜出集合)
- OR-Set (观察-删除集合)

**应用场景**:
- 协同编辑
- 分布式数据库
- 无冲突同步

**真实案例**:
- Redis Enterprise
- Riak
- Cassandra (部分)

---

### 21.6 Quorum (仲裁协议)

**原理**: N 个副本，W 个写成功，R 个读成功，满足 W + R > N 保证一致性。

**参数**:
- N: 副本数
- W: 写仲裁数
- R: 读仲裁数

**应用场景**:
- Dynamo
- Cassandra

---

## 22. 负载均衡算法

### 22.1 Round Robin

**原理**: 轮询分配。

**复杂度**: O(1)

**变种**:
- 加权轮询
- 平滑加权轮询 (Nginx)

**应用场景**:
- DNS 负载均衡
- Nginx upstream
- Kubernetes Service

**真实案例**:
- Nginx
- HAProxy

---

### 22.2 Least Connections

**原理**: 最少连接数。

**复杂度**: O(n) 或 O(log n)

**应用场景**:
- 长连接 (WebSocket)
- 数据库连接池
- RPC 框架

**真实案例**:
- Nginx least_conn
- Envoy

---

### 22.3 一致性哈希

见 [18.1 一致性哈希](#181-一致性哈希)

---

### 22.4 Power of Two Choices

**原理**: 随机选两个节点，选负载小的。

**复杂度**: O(1)

**理论**: 最大负载从 log n 降到 log log n

**应用场景**:
- Nginx random two least_conn
- 分布式任务调度

**真实案例**:
- Google Maglev
- Envoy

---

### 22.5 加权随机

**原理**: 按权重随机选择。

**实现**:
- 轮盘赌算法
- Alias Method O(1)

---

### 22.6 IP Hash

**原理**: 根据客户端 IP 哈希。

**应用场景**:
- 会话保持

---

## 23. 限流算法

### 23.1 Token Bucket (令牌桶)

**原理**: 固定速率生成令牌，请求消耗令牌。

**参数**:
- 桶容量 (burst size)
- 令牌生成速率 (rate)

**应用场景**:
- API 限流
- 网络流量整形
- QoS

**真实案例**:
- AWS API Gateway
- Google Cloud APIs
- Linux tc

---

### 23.2 Leaky Bucket (漏桶)

**原理**: 固定速率流出。

**区别**:
- 漏桶: 固定流出，平滑输出
- 令牌桶: 允许突发

**应用场景**:
- 流量整形
- 消息队列削峰

**真实案例**:
- Nginx limit_req

---

### 23.3 Fixed Window (固定窗口)

**原理**: 固定时间窗口限制请求数。

**复杂度**: O(1)

**问题**: 边界突刺

---

### 23.4 Sliding Window (滑动窗口)

**原理**: 滑动时间窗口统计。

**实现**:
- 滑动日志 (精确)
- 分片窗口 (近似)

**应用场景**:
- 精确限流
- 监控告警

**真实案例**:
- Redis + Lua
- Sentinel

---

## 24. 一致性算法

### 24.1 两阶段提交 (2PC)

**原理**:
- Phase 1: Prepare
- Phase 2: Commit/Abort

**复杂度**:
- 消息: 3n
- 时延: 2 RTT

**应用场景**:
- 分布式事务
- 数据库跨库操作

**真实案例**:
- MySQL XA
- Java JTA

**缺点**:
- 同步阻塞
- 单点故障
- 数据不一致风险

---

### 24.2 三阶段提交 (3PC)

**原理**: 2PC + PreCommit + 超时机制。

**改进**:
- 减少阻塞
- 超时机制

**应用场景**:
- 学术研究

---

### 24.3 TCC (Try-Confirm-Cancel)

**原理**: 业务层两阶段提交。

**阶段**:
- Try: 预留资源
- Confirm: 确认提交
- Cancel: 取消补偿

**应用场景**:
- 微服务分布式事务
- 电商订单

**真实案例**:
- 阿里 Seata TCC
- 蚂蚁金服

---

### 24.4 Saga

**原理**: 长事务拆分 + 补偿事务。

**模式**:
- 编排 (Orchestration)
- 编排 (Choreography)

**应用场景**:
- 长流程业务
- 微服务架构

**真实案例**:
- Uber 微服务编排
- Netflix Conductor

---

## 学习路线建议

### 初级阶段 (1-3 个月)

**数据结构**:
- 数组、链表、栈、队列
- 哈希表
- 二叉搜索树

**算法**:
- 排序: 快排、归并、堆排序
- 搜索: 二分查找
- 双指针、滑动窗口

**实践**:
- LeetCode Easy 100 题
- 实现基础数据结构

---

### 中级阶段 (3-6 个月)

**数据结构**:
- 红黑树、AVL 树
- Trie、并查集
- 堆、优先队列
- LRU Cache

**算法**:
- 动态规划 (背包、LCS、LIS)
- 图算法 (DFS、BFS、Dijkstra)
- 字符串 (KMP、Rabin-Karp)
- 贪心、回溯

**实践**:
- LeetCode Medium 150 题
- 实现 B+Tree, Skip List
- 实现 LRU Cache

---

### 高级阶段 (6-12 个月)

**数据结构**:
- B+Tree, LSM-Tree
- 布隆过滤器, HyperLogLog
- 线段树, 树状数组

**算法**:
- 分布式: Raft, Paxos, Gossip
- 一致性: 2PC, TCC, Saga
- 高级 DP, 网络流
- 加密: AES, RSA, ECC

**实践**:
- LeetCode Hard 100 题
- 实现 Raft 算法
- 实现 LSM-Tree 存储引擎
- 实现分布式事务框架

---

## 推荐资源

### 书籍
- 《算法导论》(CLRS) - 理论基础
- 《Designing Data-Intensive Applications》(DDIA) - 分布式必读
- 《算法 第4版》(Sedgewick) - 工程实践
- 《深入理解计算机系统》(CSAPP) - 系统底层
- 《数据结构与算法分析》(Weiss) - C++ 实现
- 《编程珠玑》 - 优化技巧

### 在线课程
- MIT 6.824 Distributed Systems
- Princeton Algorithms (Coursera)
- UC Berkeley CS 61B (数据结构)
- Stanford CS 161 (算法)

### 刷题平台
- LeetCode / 力扣
- Codeforces (竞赛)
- HackerRank
- Project Euler (数学)

### 开源项目
- **etcd**: Raft 实现 (Go)
- **Redis**: 数据结构实现 (C)
- **RocksDB**: LSM-Tree (C++)
- **Nginx**: 负载均衡 (C)
- **Linux Kernel**: 红黑树、跳表

### 经典论文
- MapReduce (Google, 2004)
- Raft (2014)
- Dynamo (Amazon, 2007)
- BigTable (Google, 2006)
- Paxos (Lamport, 1998)
- CAP Theorem (Brewer, 2000)

---

## 总结

本文档涵盖:

### 数据结构 (18 类)
- 基础: 数组、链表、栈、队列
- 树: BST、AVL、红黑树、B+Tree、Trie、线段树、树状数组、并查集
- 哈希: 哈希表、布隆过滤器、Count-Min Sketch、HyperLogLog
- 堆: 二叉堆、斐波那契堆
- 图: 邻接矩阵、邻接表
- 高级: 跳表、LSM-Tree、倒排索引、Bitmap、Roaring Bitmap

### 算法 (18 类)
- 排序: 10+ 种排序算法
- 搜索: 二分、插值、斐波那契
- 字符串: KMP、Boyer-Moore、AC 自动机、Manacher、后缀数组
- 图: DFS、BFS、Dijkstra、Bellman-Ford、Floyd、A*、SPFA、拓扑、MST、强连通、二分图、网络流
- 动态规划: 背包、LCS、LIS、编辑距离、区间 DP、状态压缩、树形 DP
- 贪心、分治、回溯
- 数学: 质数、GCD、快速幂、矩阵快速幂、线性筛、CRT
- 位运算
- 压缩: Huffman、LZ77、Snappy、Zstandard、Brotli
- 哈希: 一致性哈希、MurmurHash、xxHash、SHA-256、CityHash
- 加密: AES、RSA、ECC、ChaCha20
- 缓存淘汰: LRU、LFU、ARC、FIFO、CLOCK、2Q
- 分布式: Raft、Paxos、Gossip、Vector Clock、CRDT、Quorum
- 负载均衡: Round Robin、Least Connections、一致性哈希、Power of Two、加权、IP Hash
- 限流: Token Bucket、Leaky Bucket、Fixed Window、Sliding Window
- 一致性: 2PC、3PC、TCC、Saga

**学习建议**:
- 理解原理 > 记忆细节
- 手写代码 > 看懂代码
- 真实应用 > 理论知识
- 关注 trade-offs

---

**最后更新**: 2025-01-28
**维护者**: Interview-oriented Programming Repository
**版本**: v2.0 (数据结构与算法分离版)
