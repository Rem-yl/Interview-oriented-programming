# 哈希函数学习项目

本项目提供了关于哈希函数的详细学习资料和Go语言实现示例。

## 📚 项目结构

```
hash-learn/
├── 哈希函数学习文档.md    # 详细的学习文档
├── examples/              # 示例代码
│   ├── basic_hash/        # 基础哈希函数
│   │   └── main.go        # DJB2, FNV-1a, SHA-256
│   ├── password_hash/     # 密码哈希
│   │   └── main.go        # bcrypt演示
│   └── consistent_hash/   # 一致性哈希
│       └── main.go        # 分布式哈希演示
├── md5/                   # MD5算法实现
│   └── md5.go            # 完整的MD5实现与对比
├── go.mod                # Go模块定义
└── README.md             # 本文件
```

## 📖 学习文档

详细的学习文档 `哈希函数学习文档.md` 包含以下内容：

1. **哈希函数的背景与问题**
   - 提出背景和历史演进
   - 解决的核心问题

2. **哈希函数的底层原理与设计要求**
   - 核心机制（混淆、扩散、压缩映射）
   - 设计要求（单向性、抗碰撞等）
   - 生日悖论与碰撞概率

3. **常见哈希函数对比**
   - 非密码学哈希函数（DJB2, FNV-1a, MurmurHash3等）
   - 密码学哈希函数（MD5, SHA系列, bcrypt, Argon2等）
   - 详细的优缺点分析

4. **常见哈希函数原理与Go代码演示**
   - DJB2、FNV-1a、SHA-256、bcrypt、一致性哈希等

5. **MD5算法实现与改进方向**
   - MD5算法原理详解
   - 完整的Go实现
   - 工业级MD5的10个改进方向

## 🚀 快速开始

### 前置要求

- Go 1.23.0 或更高版本

### 安装依赖

```bash
go mod tidy
```

### 运行示例

#### 1. 基础哈希函数演示

展示 DJB2、FNV-1a、SHA-256 等算法：

```bash
go run examples/basic_hash/main.go
```

输出示例：
- DJB2和FNV-1a的哈希结果
- SHA-256的完整演示
- 雪崩效应演示

#### 2. 密码哈希演示

展示 bcrypt 的使用：

```bash
go run examples/password_hash/main.go
```

演示内容：
- 不同cost值的性能对比
- 密码验证
- 相同密码的不同哈希（盐值不同）

#### 3. 一致性哈希演示

分布式系统中的一致性哈希：

```bash
go run examples/consistent_hash/main.go
```

演示内容：
- 节点添加和删除
- 数据分布和迁移
- 负载均衡效果

#### 4. MD5算法实现

完整的MD5实现与测试：

```bash
go run md5/md5.go
```

演示内容：
- 自实现的MD5算法
- 与标准库对比验证
- MD5特性演示（确定性、雪崩效应、固定输出长度）
- 安全性说明和替代方案

## 🎯 学习路径

建议按以下顺序学习：

1. **阅读学习文档** (`哈希函数学习文档.md`)
   - 了解哈希函数的背景和原理
   - 理解不同类型哈希函数的设计目标

2. **运行基础示例** (`examples/basic_hash/main.go`)
   - 理解简单哈希算法的实现
   - 观察雪崩效应

3. **研究密码哈希** (`examples/password_hash/main.go`)
   - 理解为什么密码存储需要特殊的哈希函数
   - 学习bcrypt的使用

4. **探索分布式应用** (`examples/consistent_hash/main.go`)
   - 理解一致性哈希在分布式系统中的应用
   - 观察节点增减时的数据迁移

5. **深入MD5实现** (`md5/md5.go`)
   - 理解密码学哈希的内部机制
   - 学习MD5的局限性和改进方向

## 📝 代码说明

### 示例1：DJB2算法

```go
func djb2(s string) uint32 {
    hash := uint32(5381)
    for _, c := range s {
        hash = ((hash << 5) + hash) + uint32(c) // hash * 33 + c
    }
    return hash
}
```

特点：简单快速，适合哈希表使用

### 示例2：FNV-1a算法

```go
func fnv1a32(data []byte) uint32 {
    hash := uint32(2166136261)
    for _, b := range data {
        hash ^= uint32(b)
        hash *= 16777619
    }
    return hash
}
```

特点：分布均匀，实现简单

### 示例3：MD5算法

MD5实现包含：
- 消息填充（padding）
- 分块处理（512位块）
- 4轮迭代（每轮16步，共64步）
- 非线性函数（F, G, H, I）
- 与标准库完全一致的输出

## ⚠️ 安全注意事项

### 不安全的哈希函数
- **MD5**: 已被碰撞攻击破解，不应用于安全场景
- **SHA-1**: 2017年被谷歌证明可碰撞，逐步淘汰

### 推荐使用
| 场景 | 推荐算法 |
|------|---------|
| 文件完整性校验 | SHA-256 |
| 密码存储 | Argon2id, bcrypt |
| 数字签名 | SHA-256/SHA-512 |
| 高性能哈希表 | xxHash, MurmurHash3 |
| 区块链 | SHA-256 |

## 🔍 关键概念

### 雪崩效应
输入的微小变化导致输出的巨大差异。例如：
- `MD5("hello")` = `5d41402abc4b2a76b9719d911017c592`
- `MD5("hallo")` = `598d4c200461b81522a3328565c25f7c`

改变一个字符，约50%的输出位发生变化。

### 碰撞抗性
计算上不可行找到两个不同的输入产生相同的哈希值。

根据生日悖论：
- MD5（128位）：2^64次尝试 → 已被攻破
- SHA-256（256位）：2^128次尝试 → 目前安全

### 一致性哈希
分布式系统中，节点增减时只需迁移约1/N的数据（N为节点数）。

虚拟节点技术可以改善负载均衡。

## 📚 参考资料

- RFC 1321: MD5算法规范
- FIPS 180-4: SHA系列标准
- bcrypt论文：A Future-Adaptable Password Scheme
- 《深入理解计算机系统》（CSAPP）
- 《设计数据密集型应用》（DDIA）

## 🤝 贡献

欢迎提出问题和改进建议！

## 📄 许可

本项目仅供学习使用。
